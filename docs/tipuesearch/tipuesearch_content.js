var tipuesearch = {"pages":[{"title":" Boussinesq DNS ","text":"Boussinesq DNS Developer Info Costanza Rodda","tags":"home","loc":"index.html"},{"title":"rang – Boussinesq DNS","text":"function rang(i) Arguments Type Intent Optional Attributes Name integer :: i Return Value real","tags":"","loc":"proc/rang.html"},{"title":"ranno – Boussinesq DNS","text":"function ranno(i) Arguments Type Intent Optional Attributes Name integer :: i Return Value real","tags":"","loc":"proc/ranno.html"},{"title":"ran1 – Boussinesq DNS","text":"function ran1(idum) Arguments Type Intent Optional Attributes Name integer :: idum Return Value real","tags":"","loc":"proc/ran1.html"},{"title":"init_params – Boussinesq DNS","text":"subroutine init_params() Uses param $        if (wk.eq.0.)                                                     L(ikx,iky,ikz) = 0\n$        if (wk.eq.0. .or. wk.gt.ifix(KTRUNC_X + 0.5) - 0.5)                L(ikx,iky,ikz) = 0\n$        if (abs(kx L1/twopi).gt.int(float(n1)/3. + 0.5)-0.5)              L(ikx,iky,ikz) = 0\n$        if (abs(ky L2/twopi).gt.int(float(n2)/3. + 0.5)-0.5)              L(ikx,iky,ikz) = 0\n$        if (abs(kz*L3/twopi).gt.int(float(n3)/3. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !    ! cubic truncation with 8/9 instead of 2/3 truncation\n$         if (abs(kx L1/twopi).gt.int(float(n1) 4./9. + 0.5)-0.5)              L(ikx,iky,ikz) = 0\n$         if (abs(ky L2/twopi).gt.int(float(n2) 4./9. + 0.5)-0.5)              L(ikx,iky,ikz) = 0\n$         if (abs(kz L3/twopi).gt.int(float(n3) 4./9. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 Arguments None","tags":"","loc":"proc/init_params.html"},{"title":"energy_full – Boussinesq DNS","text":"subroutine energy_full(zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, ke, pe, eg, ea) Uses param velvorproj nm_decomp Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(inout), dimension(iktx,ikty,iktzp) :: ge complex, intent(inout), dimension(iktx,ikty,iktzp) :: g1 complex, intent(inout), dimension(iktx,ikty,iktzp) :: g2 real, intent(out) :: ke real, intent(out) :: pe real, intent(out) :: eg real, intent(out) :: ea","tags":"","loc":"proc/energy_full.html"},{"title":"cfl – Boussinesq DNS","text":"subroutine cfl(zx, zy, zz, ux, uy, uz, ur, vr, wr) Uses param param_fftw velvorproj Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr","tags":"","loc":"proc/cfl.html"},{"title":"convol – Boussinesq DNS","text":"subroutine convol(zxk, zyk, zzk, ttk, nxk, nyk, nzk, ntk, uk, vk, wk, ur, vr, wr, wxk, wyk, wzk, wtk, zxr, zyr, zzr, ttr, nxr, nyr, nzr, ntr) Uses param param_fftw velvorproj Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(out), dimension(iktx,ikty,iktzp) :: nxk complex, intent(out), dimension(iktx,ikty,iktzp) :: nyk complex, intent(out), dimension(iktx,ikty,iktzp) :: nzk complex, intent(out), dimension(iktx,ikty,iktzp) :: ntk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr complex, intent(inout), dimension(iktx,ikty,iktzp) :: wxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wtk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: nxr real, intent(inout), dimension(n1d,n3d,n2dp) :: nyr real, intent(inout), dimension(n1d,n3d,n2dp) :: nzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ntr","tags":"","loc":"proc/convol.html"},{"title":"constr – Boussinesq DNS","text":"subroutine constr(zxk, zyk, zzk, ttk, nxk, nyk, nzk, ntk, uk, vk, wk, ur, vr, wr, zxr, zyr, zzr, ttr, nxr, nyr, nzr, ntr) Uses param param_fftw velvorproj Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(out), dimension(iktx,ikty,iktzp) :: nxk complex, intent(out), dimension(iktx,ikty,iktzp) :: nyk complex, intent(out), dimension(iktx,ikty,iktzp) :: nzk complex, intent(out), dimension(iktx,ikty,iktzp) :: ntk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(out), dimension(n1d,n3d,n2dp) :: nxr real, intent(out), dimension(n1d,n3d,n2dp) :: nyr real, intent(out), dimension(n1d,n3d,n2dp) :: nzr real, intent(out), dimension(n1d,n3d,n2dp) :: ntr","tags":"","loc":"proc/constr.html"},{"title":"fftwrk – Boussinesq DNS","text":"subroutine fftwrk(plan, zr, zk) Uses param param_fftw Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in) :: plan real, intent(inout), dimension(n1d,n3d,n2dp) :: zr complex, intent(inout), dimension(iktx,ikty,iktzp) :: zk","tags":"","loc":"proc/fftwrk.html"},{"title":"fftwkr – Boussinesq DNS","text":"subroutine fftwkr(plan, zk, zr) Uses param param_fftw Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in) :: plan complex, intent(inout), dimension(iktx,ikty,iktzp) :: zk real, intent(inout), dimension(n1d,n3d,n2dp) :: zr","tags":"","loc":"proc/fftwkr.html"},{"title":"realit – Boussinesq DNS","text":"subroutine realit(zk) Uses param param_fftw Arguments Type Intent Optional Attributes Name complex, intent(inout) :: zk (iktx,ikty,iktzp)","tags":"","loc":"proc/realit.html"},{"title":"velo – Boussinesq DNS","text":"public  subroutine velo(zx, zy, zz, u, v, w) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: u complex, intent(out), dimension(iktx,ikty,iktzp) :: v complex, intent(out), dimension(iktx,ikty,iktzp) :: w","tags":"","loc":"proc/velo.html"},{"title":"vort – Boussinesq DNS","text":"public  subroutine vort(u, v, w, zx, zy, zz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: u complex, intent(in), dimension(iktx,ikty,iktzp) :: v complex, intent(in), dimension(iktx,ikty,iktzp) :: w complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz","tags":"","loc":"proc/vort.html"},{"title":"proj – Boussinesq DNS","text":"public  subroutine proj(zx, zy, zz) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zx complex, intent(inout), dimension(iktx,ikty,iktzp) :: zy complex, intent(inout), dimension(iktx,ikty,iktzp) :: zz","tags":"","loc":"proc/proj.html"},{"title":"prep_realslice – Boussinesq DNS","text":"public  subroutine prep_realslice() $  real, dimension(nHor):: xr,yr\n$  real, dimension(nVer):: zr Arguments None","tags":"","loc":"proc/prep_realslice.html"},{"title":"dump_realspace – Boussinesq DNS","text":"public  subroutine dump_realspace(zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr","tags":"","loc":"proc/dump_realspace.html"},{"title":"dump_horslice – Boussinesq DNS","text":"public  subroutine dump_horslice(fr, idhvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idhvar","tags":"","loc":"proc/dump_horslice.html"},{"title":"dump_verslice – Boussinesq DNS","text":"public  subroutine dump_verslice(fr, idvvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idvvar","tags":"","loc":"proc/dump_verslice.html"},{"title":"close_ncf_realspace – Boussinesq DNS","text":"public  subroutine close_ncf_realspace() Arguments None","tags":"","loc":"proc/close_ncf_realspace.html"},{"title":"wtoab – Boussinesq DNS","text":"public  subroutine wtoab(zx, zy, zz, tt, geok, gw1k, gw2k, u, v, w) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(out), dimension(iktx,ikty,iktzp) :: geok complex, intent(out), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(out), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(inout), dimension(iktx,ikty,iktzp) :: u complex, intent(inout), dimension(iktx,ikty,iktzp) :: v complex, intent(inout), dimension(iktx,ikty,iktzp) :: w","tags":"","loc":"proc/wtoab.html"},{"title":"atowb – Boussinesq DNS","text":"public  subroutine atowb(geok, gw1k, gw2k, zx, zy, zz, tt, u, v, w) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: geok complex, intent(in), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(in), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: u complex, intent(inout), dimension(iktx,ikty,iktzp) :: v complex, intent(inout), dimension(iktx,ikty,iktzp) :: w","tags":"","loc":"proc/atowb.html"},{"title":"prep_realslice – Boussinesq DNS","text":"public  subroutine prep_realslice() $  real, dimension(nHor):: xr,yr\n$  real, dimension(nVer):: zr Arguments None","tags":"","loc":"proc/prep_realslice~2.html"},{"title":"dump_realspace – Boussinesq DNS","text":"public  subroutine dump_realspace(zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr","tags":"","loc":"proc/dump_realspace~2.html"},{"title":"dump_horslice – Boussinesq DNS","text":"public  subroutine dump_horslice(fr, idhvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idhvar","tags":"","loc":"proc/dump_horslice~2.html"},{"title":"dump_verslice – Boussinesq DNS","text":"public  subroutine dump_verslice(fr, idvvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idvvar","tags":"","loc":"proc/dump_verslice~2.html"},{"title":"close_ncf_realspace – Boussinesq DNS","text":"public  subroutine close_ncf_realspace() Arguments None","tags":"","loc":"proc/close_ncf_realspace~2.html"},{"title":"prep_diagnostics – Boussinesq DNS","text":"public  subroutine prep_diagnostics() Arguments None","tags":"","loc":"proc/prep_diagnostics.html"},{"title":"out_eng – Boussinesq DNS","text":"public  subroutine out_eng(zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, zxwv, zywv, zzwv, ttwv, nt) prints the energies and flow parameters in an output file (e.g. \"run.list\")\nalso dumps the energies and dissipations as function of time in 'eng.dat' and 'eps.dat'\nNote: zx,zy,zz,tt,ge,g1,g2 would not change in this subroutine but\nux,uy,uz,zxwv,zywv,zzwv,ttwv do change\nusually rhzx,rhzy,rhzz are used for zxwv,zywv,zzwv,ttwv to save memory\nHence, pay attention when using \"uk,vk,wk,nttk,rhzx,rhzy,rhzz\"\ndecomposing wave energy to a kinetic and potential part Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(in), dimension(iktx,ikty,iktzp) :: ge complex, intent(in), dimension(iktx,ikty,iktzp) :: g1 complex, intent(in), dimension(iktx,ikty,iktzp) :: g2 complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zywv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttwv integer, intent(in) :: nt","tags":"","loc":"proc/out_eng.html"},{"title":"spec – Boussinesq DNS","text":"public  subroutine spec(zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, zxwv, zywv, zzwv, ttwv, ispec, iu) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(in), dimension(iktx,ikty,iktzp) :: ge complex, intent(in), dimension(iktx,ikty,iktzp) :: g1 complex, intent(in), dimension(iktx,ikty,iktzp) :: g2 complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zywv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttwv integer, intent(in) :: ispec integer, intent(in) :: iu","tags":"","loc":"proc/spec.html"},{"title":"transf – Boussinesq DNS","text":"public  subroutine transf(zx, zy, zz, tt, geok, gw1k, gw2k, nzx, nzy, nzz, ntt, ngeok, ngw1k, ngw2k, nuk, nvk, nwk, ispec, iu) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(in), dimension(iktx,ikty,iktzp) :: geok complex, intent(in), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(in), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(in), dimension(iktx,ikty,iktzp) :: nzx complex, intent(in), dimension(iktx,ikty,iktzp) :: nzy complex, intent(in), dimension(iktx,ikty,iktzp) :: nzz complex, intent(in), dimension(iktx,ikty,iktzp) :: ntt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ngeok complex, intent(inout), dimension(iktx,ikty,iktzp) :: ngw1k complex, intent(inout), dimension(iktx,ikty,iktzp) :: ngw2k complex, intent(inout), dimension(iktx,ikty,iktzp) :: nuk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nvk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nwk integer, intent(in) :: ispec integer, intent(in) :: iu","tags":"","loc":"proc/transf.html"},{"title":"do_diagnostics – Boussinesq DNS","text":"public  subroutine do_diagnostics(zx, zy, zz, tt, geok, gw1k, gw2k, nzxk, nzyk, nzzk, nttk, rhzx, rhzy, rhzz, rhtt, uk, vk, wk, nt) Do all the diagnostics here. Customise based on what you need for analysis Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(in), dimension(iktx,ikty,iktzp) :: geok complex, intent(in), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(in), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(in), dimension(iktx,ikty,iktzp) :: nzxk complex, intent(in), dimension(iktx,ikty,iktzp) :: nzyk complex, intent(in), dimension(iktx,ikty,iktzp) :: nzzk complex, intent(in), dimension(iktx,ikty,iktzp) :: nttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhzx Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhzy Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhzz Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhtt Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but integer, intent(in) :: nt","tags":"","loc":"proc/do_diagnostics.html"},{"title":"check – Boussinesq DNS","text":"public  subroutine check(status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status","tags":"","loc":"proc/check.html"},{"title":"ncdumpout – Boussinesq DNS","text":"public  subroutine ncdumpout(zx, zy, zz, tt) Create netcdf files and write the fields for restart (output)\nOnly zx,zy,zz and tt are dumped in a netcdf file Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt","tags":"","loc":"proc/ncdumpout.html"},{"title":"ncreadin – Boussinesq DNS","text":"public  subroutine ncreadin(zx, zy, zz, tt, ts) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt real, intent(out) :: ts","tags":"","loc":"proc/ncreadin.html"},{"title":"prep_realslice – Boussinesq DNS","text":"public  subroutine prep_realslice() $  real, dimension(nHor):: xr,yr\n$  real, dimension(nVer):: zr Arguments None","tags":"","loc":"proc/prep_realslice~3.html"},{"title":"dump_realspace – Boussinesq DNS","text":"public  subroutine dump_realspace(zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr","tags":"","loc":"proc/dump_realspace~3.html"},{"title":"dump_horslice – Boussinesq DNS","text":"public  subroutine dump_horslice(fr, idhvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idhvar","tags":"","loc":"proc/dump_horslice~3.html"},{"title":"dump_verslice – Boussinesq DNS","text":"public  subroutine dump_verslice(fr, idvvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idvvar","tags":"","loc":"proc/dump_verslice~3.html"},{"title":"close_ncf_realspace – Boussinesq DNS","text":"public  subroutine close_ncf_realspace() Arguments None","tags":"","loc":"proc/close_ncf_realspace~3.html"},{"title":"printparameters – Boussinesq DNS","text":"public  subroutine printparameters() Arguments None","tags":"","loc":"proc/printparameters.html"},{"title":"pvcomp – Boussinesq DNS","text":"public  subroutine pvcomp(zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) $  term1=0\n$  do ii= 1,n1d\n$     do jj= 1,n3d\n$        do kk= 1,n2dp\n$           term1 = term1 + zzr(ii,jj,kk)*zzr(ii,jj,kk)\n$        enddo\n$     enddo\n$  enddo $  call fftwrk(plan3_zxnr_zxnk,zxr,zxk)\n$  call fftwrk(plan3_zynr_zynk,zyr,zyk)\n$  call fftwrk(plan3_zznr_zznk,zzr,zzk) $   if (mype.eq.0) then\n$     print ,' max of diff = ', maxval(real((zzk-azk) conjg(zzk-azk)))\n$   endif Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr","tags":"","loc":"proc/pvcomp.html"},{"title":"rang – Boussinesq DNS","text":"public  function rang(i) Arguments Type Intent Optional Attributes Name integer :: i Return Value real","tags":"","loc":"proc/rang~2.html"},{"title":"ranno – Boussinesq DNS","text":"public  function ranno(i) Arguments Type Intent Optional Attributes Name integer :: i Return Value real","tags":"","loc":"proc/ranno~2.html"},{"title":"ran1 – Boussinesq DNS","text":"public  function ran1(idum) Arguments Type Intent Optional Attributes Name integer :: idum Return Value real","tags":"","loc":"proc/ran1~2.html"},{"title":"force – Boussinesq DNS","text":"public  subroutine force(nzxk, nzyk, nzzk, nttk, gtau, nt) ! specify amplitudes of vort and wave forcing separately\n$                 pk = pk + real(conjg(zx(ikx,iky,ikz)) f1k/wk2)\n$                 pk = pk + real(conjg(zy(ikx,iky,ikz)) f2k/wk2)\n$                 pk = pk + real(conjg(zz(ikx,iky,ikz)) f3k/wk2)\n$                 pp = pp + real(conjg(tt(ikx,iky,ikz)) ftk)*aj/bj ! new: force everything isotropically. Use ampv as global amplitude. $  if (mod(nt,ndiagevery).eq. 0 ) then\n$     call mpi_reduce(pk,tmp,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,istatus); pk=tmp\n$     call mpi_reduce(pp,tmp,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,istatus); pp=tmp\n$     if (mype.eq.0) then\n$        write(98,4999) time,pk,pp\n$        call flush(98)\n$     endif\n$  endif Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: nzxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nzyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nzzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nttk complex, intent(inout) :: gtau (1200,4) integer, intent(in) :: nt","tags":"","loc":"proc/force.html"},{"title":"init_cond – Boussinesq DNS","text":"public  subroutine init_cond(zx, zy, zz, tt, uu, vv, ww, ge, g1, g2, zxr, zyr, zzr, ttr, ur, vr, wr, ts) $     ! superpostion of input NetCDF file and user defined fields\n$     ! for user defined fields you can use the functions in this module like single_planewave ...\n$     allocate(zx0(iktx,ikty,iktzp))\n$     allocate(zy0(iktx,ikty,iktzp))\n$     allocate(zz0(iktx,ikty,iktzp))\n$     allocate(tt0(iktx,ikty,iktzp))\n$     call ncreadin(zx,zy,zz,tt,ts)\n$\n$     ! superposing the wave field and background QG\n$     zx = zx + zx0\n$     zy = zy + zy0\n$     zz = zz + zz0\n$     tt = tt + tt0\n$\n$     ! free the memory for auxilliary variables\n$     deallocate(zx0,zy0,zz0,tt0) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt complex, intent(out), dimension(iktx,ikty,iktzp) :: uu complex, intent(out), dimension(iktx,ikty,iktzp) :: vv complex, intent(out), dimension(iktx,ikty,iktzp) :: ww complex, intent(out), dimension(iktx,ikty,iktzp) :: ge complex, intent(out), dimension(iktx,ikty,iktzp) :: g1 complex, intent(out), dimension(iktx,ikty,iktzp) :: g2 real, intent(out), dimension(n1d,n3d,n2dp) :: zxr real, intent(out), dimension(n1d,n3d,n2dp) :: zyr real, intent(out), dimension(n1d,n3d,n2dp) :: zzr real, intent(out), dimension(n1d,n3d,n2dp) :: ttr real, intent(out), dimension(n1d,n3d,n2dp) :: ur real, intent(out), dimension(n1d,n3d,n2dp) :: vr real, intent(out), dimension(n1d,n3d,n2dp) :: wr real, intent(out) :: ts","tags":"","loc":"proc/init_cond.html"},{"title":"exp_peak – Boussinesq DNS","text":"public  subroutine exp_peak(zx, zy, zz, tt, uu, vv, ww, ge, g1, g2) ! Initialize in Fourier space with Gausian peak at ki (defined above) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt complex, intent(out), dimension(iktx,ikty,iktzp) :: uu complex, intent(out), dimension(iktx,ikty,iktzp) :: vv complex, intent(out), dimension(iktx,ikty,iktzp) :: ww complex, intent(out), dimension(iktx,ikty,iktzp) :: ge complex, intent(out), dimension(iktx,ikty,iktzp) :: g1 complex, intent(out), dimension(iktx,ikty,iktzp) :: g2","tags":"","loc":"proc/exp_peak.html"},{"title":"energy_full – Boussinesq DNS","text":"public  subroutine energy_full(zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, ke, pe, eg, ea) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(inout), dimension(iktx,ikty,iktzp) :: ge complex, intent(inout), dimension(iktx,ikty,iktzp) :: g1 complex, intent(inout), dimension(iktx,ikty,iktzp) :: g2 real, intent(out) :: ke real, intent(out) :: pe real, intent(out) :: eg real, intent(out) :: ea","tags":"","loc":"proc/energy_full~2.html"},{"title":"velvorproj – Boussinesq DNS","text":"Uses param Subroutines public  subroutine velo (zx, zy, zz, u, v, w) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: u complex, intent(out), dimension(iktx,ikty,iktzp) :: v complex, intent(out), dimension(iktx,ikty,iktzp) :: w public  subroutine vort (u, v, w, zx, zy, zz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: u complex, intent(in), dimension(iktx,ikty,iktzp) :: v complex, intent(in), dimension(iktx,ikty,iktzp) :: w complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz public  subroutine proj (zx, zy, zz) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zx complex, intent(inout), dimension(iktx,ikty,iktzp) :: zy complex, intent(inout), dimension(iktx,ikty,iktzp) :: zz","tags":"","loc":"module/velvorproj.html"},{"title":"realspacedumps2 – Boussinesq DNS","text":"%% PARAMETERs %% Uses param param_fftw velvorproj nm_decomp netcdf Variables Type Visibility Attributes Name Initial integer, public, parameter :: nHor = FLOOR(real(nHend-nHstart+1.0, 8)/nskipH) integer, public, parameter :: nVer = FLOOR(real(nVend-nVstart+1.0, 8)/nskipV) integer, public, parameter :: ihor = n3/2 integer, public, parameter :: iver = n1d/2 integer, public, save :: idslices integer, public, save :: idxrs integer, public, save :: idyrs integer, public, save :: idzrs integer, public, save :: idtmrs integer, public, save :: tmrid integer, public, save :: xxid integer, public, save :: yyid integer, public, save :: zzid integer, public, save :: zzhtotid integer, public, save :: zzvtotid integer, public, save :: zzhbrtid integer, public, save :: zzvbrtid integer, public, save :: uuhtotid integer, public, save :: uuvtotid integer, public, save :: vvhtotid integer, public, save :: vvvtotid integer, public, save :: uuhbrcid integer, public, save :: uuvbrcid integer, public, save :: vvhbrcid integer, public, save :: vvvbrcid integer, public, save :: qdhtotid integer, public, save :: qdvtotid integer, public, save :: qdhbrtid integer, public, save :: qdvbrtid integer, public, save :: iRScount Make internal variables and functions private Subroutines public  subroutine prep_realslice () $  real, dimension(nHor):: xr,yr\n$  real, dimension(nVer):: zr Arguments None public  subroutine dump_realspace (zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr public  subroutine dump_horslice (fr, idhvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idhvar public  subroutine dump_verslice (fr, idvvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idvvar public  subroutine close_ncf_realspace () Arguments None","tags":"","loc":"module/realspacedumps2~2.html"},{"title":"nm_decomp – Boussinesq DNS","text":"Uses velvorproj Subroutines public  subroutine wtoab (zx, zy, zz, tt, geok, gw1k, gw2k, u, v, w) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(out), dimension(iktx,ikty,iktzp) :: geok complex, intent(out), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(out), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(inout), dimension(iktx,ikty,iktzp) :: u complex, intent(inout), dimension(iktx,ikty,iktzp) :: v complex, intent(inout), dimension(iktx,ikty,iktzp) :: w public  subroutine atowb (geok, gw1k, gw2k, zx, zy, zz, tt, u, v, w) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: geok complex, intent(in), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(in), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: u complex, intent(inout), dimension(iktx,ikty,iktzp) :: v complex, intent(inout), dimension(iktx,ikty,iktzp) :: w","tags":"","loc":"module/nm_decomp.html"},{"title":"realspacedumps2 – Boussinesq DNS","text":"%% PARAMETERs %% Uses param param_fftw velvorproj nm_decomp netcdf Variables Type Visibility Attributes Name Initial integer, public, parameter :: nHor = FLOOR(real(nHend-nHstart+1.0, 8)/nskipH) integer, public, parameter :: nVer = FLOOR(real(nVend-nVstart+1.0, 8)/nskipV) integer, public, parameter :: ihor = n3/2 integer, public, parameter :: iver = n1d/2 integer, public, save :: idslices integer, public, save :: idxrs integer, public, save :: idyrs integer, public, save :: idzrs integer, public, save :: idtmrs integer, public, save :: tmrid integer, public, save :: xxid integer, public, save :: yyid integer, public, save :: zzid integer, public, save :: zzhtotid integer, public, save :: zzvtotid integer, public, save :: zzhbrtid integer, public, save :: zzvbrtid integer, public, save :: uuhtotid integer, public, save :: uuvtotid integer, public, save :: vvhtotid integer, public, save :: vvvtotid integer, public, save :: uuhbrcid integer, public, save :: uuvbrcid integer, public, save :: vvhbrcid integer, public, save :: vvvbrcid integer, public, save :: qdhtotid integer, public, save :: qdvtotid integer, public, save :: qdhbrcid integer, public, save :: qdvbrcid integer, public, save :: iRScount Make internal variables and functions private Subroutines public  subroutine prep_realslice () $  real, dimension(nHor):: xr,yr\n$  real, dimension(nVer):: zr Arguments None public  subroutine dump_realspace (zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr public  subroutine dump_horslice (fr, idhvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idhvar public  subroutine dump_verslice (fr, idvvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idvvar public  subroutine close_ncf_realspace () Arguments None","tags":"","loc":"module/realspacedumps2~3.html"},{"title":"diagnostics – Boussinesq DNS","text":"Wether or not keep eng.dat (time series of energys) or eps.dat (time series of dissipations) Uses nm_decomp Variables Type Visibility Attributes Name Initial integer, public, parameter :: keepENG = 1 ID for energy time series (eng.dat) and dissipation (eps.dat) integer, public, parameter :: keepEPS = 0 ID for energy time series (eng.dat) and dissipation (eps.dat) integer, public, parameter :: iuENG = 41 which ENERGY SPECTRA to keep:\nSPCH: horizontal energy spectra, SPCZ: vertical eng spectra, SPC: spherical eng spectra integer, public, parameter :: iuEPS = 42 which ENERGY SPECTRA to keep:\nSPCH: horizontal energy spectra, SPCZ: vertical eng spectra, SPC: spherical eng spectra integer, public, parameter :: iuTRNH = 71 the file IDs of each type of spectra integer, public, parameter :: iuTRNZ = 72 the file IDs of each type of spectra integer, public, parameter :: iuTRN = 73 the file IDs of each type of spectra integer, public, parameter :: iuSPCH = 51 integer, public, parameter :: iuSPCZ = 52 integer, public, parameter :: iuSPC = 53 Subroutines public  subroutine prep_diagnostics () Arguments None public  subroutine out_eng (zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, zxwv, zywv, zzwv, ttwv, nt) prints the energies and flow parameters in an output file (e.g. \"run.list\")\nalso dumps the energies and dissipations as function of time in 'eng.dat' and 'eps.dat'\nNote: zx,zy,zz,tt,ge,g1,g2 would not change in this subroutine but\nux,uy,uz,zxwv,zywv,zzwv,ttwv do change\nusually rhzx,rhzy,rhzz are used for zxwv,zywv,zzwv,ttwv to save memory\nHence, pay attention when using \"uk,vk,wk,nttk,rhzx,rhzy,rhzz\"\ndecomposing wave energy to a kinetic and potential part Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(in), dimension(iktx,ikty,iktzp) :: ge complex, intent(in), dimension(iktx,ikty,iktzp) :: g1 complex, intent(in), dimension(iktx,ikty,iktzp) :: g2 complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zywv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttwv integer, intent(in) :: nt public  subroutine spec (zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, zxwv, zywv, zzwv, ttwv, ispec, iu) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(in), dimension(iktx,ikty,iktzp) :: ge complex, intent(in), dimension(iktx,ikty,iktzp) :: g1 complex, intent(in), dimension(iktx,ikty,iktzp) :: g2 complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zywv complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzwv complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttwv integer, intent(in) :: ispec integer, intent(in) :: iu public  subroutine transf (zx, zy, zz, tt, geok, gw1k, gw2k, nzx, nzy, nzz, ntt, ngeok, ngw1k, ngw2k, nuk, nvk, nwk, ispec, iu) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(in), dimension(iktx,ikty,iktzp) :: geok complex, intent(in), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(in), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(in), dimension(iktx,ikty,iktzp) :: nzx complex, intent(in), dimension(iktx,ikty,iktzp) :: nzy complex, intent(in), dimension(iktx,ikty,iktzp) :: nzz complex, intent(in), dimension(iktx,ikty,iktzp) :: ntt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ngeok complex, intent(inout), dimension(iktx,ikty,iktzp) :: ngw1k complex, intent(inout), dimension(iktx,ikty,iktzp) :: ngw2k complex, intent(inout), dimension(iktx,ikty,iktzp) :: nuk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nvk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nwk integer, intent(in) :: ispec integer, intent(in) :: iu public  subroutine do_diagnostics (zx, zy, zz, tt, geok, gw1k, gw2k, nzxk, nzyk, nzzk, nttk, rhzx, rhzy, rhzz, rhtt, uk, vk, wk, nt) Do all the diagnostics here. Customise based on what you need for analysis Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(in), dimension(iktx,ikty,iktzp) :: geok complex, intent(in), dimension(iktx,ikty,iktzp) :: gw1k complex, intent(in), dimension(iktx,ikty,iktzp) :: gw2k complex, intent(in), dimension(iktx,ikty,iktzp) :: nzxk complex, intent(in), dimension(iktx,ikty,iktzp) :: nzyk complex, intent(in), dimension(iktx,ikty,iktzp) :: nzzk complex, intent(in), dimension(iktx,ikty,iktzp) :: nttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhzx Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhzy Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhzz Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: rhtt Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k\nremain unchanged but integer, intent(in) :: nt","tags":"","loc":"module/diagnostics.html"},{"title":"param – Boussinesq DNS","text":"Uses iso_c_binding Variables Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public, parameter :: n1 = 1024 integer(kind=C_INTPTR_T), public, parameter :: n2 = 1024 integer(kind=C_INTPTR_T), public, parameter :: n3 = 256 integer, public, save :: npe = 256 real, public, parameter :: twopi = 4.*asin(1.) real, public, parameter :: sqrt2 = sqrt(2.) complex, public, parameter :: zi = cmplx(0., 1.) real, public, save :: time real, public, parameter :: delt = 5 real, public, parameter :: tstop = 2*24*3600 integer, public, parameter :: nstop = int(tstop/delt) real, public, parameter :: PrRa = 100 real, public, parameter :: aj = 1e-2 real, public, parameter :: bj = aj real, public, parameter :: bf2 = aj*bj real, public, parameter :: bf = sqrt(bf2) real, public, parameter :: cor = 1.1e-4 real, public, parameter :: cor2 = cor*cor real, public, parameter :: L1 = 8e6 real, public, parameter :: L2 = 8e6 real, public, parameter :: L3 = 2e4 integer(kind=C_INTPTR_T), public, parameter :: n1d = n1+2 integer(kind=C_INTPTR_T), public, parameter :: n2d = n2 integer(kind=C_INTPTR_T), public, parameter :: n3d = n3 integer(kind=C_INTPTR_T), public, save :: n2dp integer(kind=C_INTPTR_T), public, save :: n2p integer(kind=C_INTPTR_T), public, parameter :: ktx = n1/2 integer(kind=C_INTPTR_T), public, parameter :: kty = n2/2 integer(kind=C_INTPTR_T), public, parameter :: ktz = n3/2 integer(kind=C_INTPTR_T), public, parameter :: iktx = ktx+1 integer(kind=C_INTPTR_T), public, parameter :: ikty = n2 integer(kind=C_INTPTR_T), public, parameter :: iktz = n3 integer(kind=C_INTPTR_T), public, save :: iktzp integer(kind=C_INTPTR_T), public, parameter :: kts = n1 real, public, parameter :: ktrunc_x = twopi/L1*float(n1)/3. real, public, parameter :: ktrunc_y = twopi/L2*float(n2)/3. real, public, parameter :: ktrunc_z = twopi/L3*float(n3)/3. integer, public, parameter :: ilap = 4 integer, public, parameter :: ilap2 = 2*ilap real, public, parameter :: vischtmp = 5.e-5*(10./ktrunc_x)**2. real, public, parameter :: viscztmp = 5.e-5*(10./ktrunc_z)**2. real, public, parameter :: visch = 3.0e26 real, public, parameter :: viscz = 1e3 viscztmp * ktrunc_z * (2-2 ilap) ! viscosity coeff vertical real, public, parameter :: ek = 1./(24.*3600.)*delt real, public, parameter :: kdamping = 3. integer, public, parameter :: forcing_flag = 1 integer, public, dimension(:,:,:), allocatable, save :: L real, public, dimension(:), allocatable, save :: kxa real, public, dimension(:), allocatable, save :: kya real, public, dimension(:), allocatable, save :: kza integer, public, save :: mype integer(kind=C_INTPTR_T), public, save :: locz integer(kind=C_INTPTR_T), public, save :: loczstart integer(kind=C_INTPTR_T), public, save :: alloc_local integer, public, save :: istatus integer, public, parameter :: icmode = 1 integer, public, parameter :: iuRESULT = 11 integer, public, parameter :: truncmode = 0 real, public, parameter :: fftnorm = float(n1*n2*n3) integer, public, parameter :: ncwrite = 1 integer, public, parameter :: ndiagout = 24 integer, public, parameter :: ndiagevery = floor(nstop/float(ndiagout)) integer, public, parameter :: realspace_flag = 0 integer, public, parameter :: nrsout = 1 integer, public, parameter :: nrsevery = floor(nstop/float(nrsout)) integer, public, parameter :: nHstart = 1 integer, public, parameter :: nHend = n1 integer, public, parameter :: nVstart = 1 integer, public, parameter :: nVend = n3 integer, public, parameter :: nskipH = 1 integer, public, parameter :: nskipV = 1","tags":"","loc":"module/param.html"},{"title":"IO_netcdf – Boussinesq DNS","text":"Uses param netcdf Variables Type Visibility Attributes Name Initial integer, public :: idink integer, public :: idoutk integer, public :: idkx integer, public :: idky integer, public :: idkz integer, public :: idkri integer, public :: idktm integer, public :: istat integer, public :: idzxk integer, public :: idzyk integer, public :: idzzk integer, public :: idttk integer, public :: idtimek Subroutines public  subroutine check (status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status public  subroutine ncdumpout (zx, zy, zz, tt) Create netcdf files and write the fields for restart (output)\nOnly zx,zy,zz and tt are dumped in a netcdf file Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt public  subroutine ncreadin (zx, zy, zz, tt, ts) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt real, intent(out) :: ts","tags":"","loc":"module/io_netcdf.html"},{"title":"realspacedumps2 – Boussinesq DNS","text":"%% PARAMETERs %% Uses param param_fftw velvorproj nm_decomp netcdf Variables Type Visibility Attributes Name Initial integer, public, parameter :: nHor = FLOOR(real(nHend-nHstart+1.0, 8)/nskipH) integer, public, parameter :: nVer = FLOOR(real(nVend-nVstart+1.0, 8)/nskipV) integer, public, parameter :: ihor = n3/2 integer, public, parameter :: iver = n1d/2 integer, public, save :: idslices integer, public, save :: idxrs integer, public, save :: idyrs integer, public, save :: idzrs integer, public, save :: idtmrs integer, public, save :: tmrid integer, public, save :: xxid integer, public, save :: yyid integer, public, save :: zzid integer, public, save :: zzhtotid integer, public, save :: zzvtotid integer, public, save :: zzhbrtid integer, public, save :: zzvbrtid integer, public, save :: uuhtotid integer, public, save :: uuvtotid integer, public, save :: vvhtotid integer, public, save :: vvvtotid integer, public, save :: uuhbrcid integer, public, save :: uuvbrcid integer, public, save :: vvhbrcid integer, public, save :: vvvbrcid integer, public, save :: uuhbrtid integer, public, save :: vvhbrtid integer, public, save :: qdhtotid integer, public, save :: qdvtotid integer, public, save :: qdhbrcid integer, public, save :: qdvbrcid integer, public, save :: iRScount Make internal variables and functions private Subroutines public  subroutine prep_realslice () $  real, dimension(nHor):: xr,yr\n$  real, dimension(nVer):: zr Arguments None public  subroutine dump_realspace (zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr public  subroutine dump_horslice (fr, idhvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idhvar public  subroutine dump_verslice (fr, idvvar) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(n1d,n3d,n2dp) :: fr integer, intent(in) :: idvvar public  subroutine close_ncf_realspace () Arguments None","tags":"","loc":"module/realspacedumps2.html"},{"title":"misc – Boussinesq DNS","text":"!!!!! unused routine for now kept here: Uses param param_fftw Subroutines public  subroutine printparameters () Arguments None public  subroutine pvcomp (zxk, zyk, zzk, ttk, uk, vk, wk, zxr, zyr, zzr, ttr, ur, vr, wr) $  term1=0\n$  do ii= 1,n1d\n$     do jj= 1,n3d\n$        do kk= 1,n2dp\n$           term1 = term1 + zzr(ii,jj,kk)*zzr(ii,jj,kk)\n$        enddo\n$     enddo\n$  enddo Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: zxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: zzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: ttk complex, intent(inout), dimension(iktx,ikty,iktzp) :: uk complex, intent(inout), dimension(iktx,ikty,iktzp) :: vk complex, intent(inout), dimension(iktx,ikty,iktzp) :: wk real, intent(inout), dimension(n1d,n3d,n2dp) :: zxr real, intent(inout), dimension(n1d,n3d,n2dp) :: zyr real, intent(inout), dimension(n1d,n3d,n2dp) :: zzr real, intent(inout), dimension(n1d,n3d,n2dp) :: ttr real, intent(inout), dimension(n1d,n3d,n2dp) :: ur real, intent(inout), dimension(n1d,n3d,n2dp) :: vr real, intent(inout), dimension(n1d,n3d,n2dp) :: wr","tags":"","loc":"module/misc.html"},{"title":"forcing – Boussinesq DNS","text":"Uses param velvorproj Variables Type Visibility Attributes Name Initial real, public, parameter :: kf = 3. real, public, parameter :: tau = 900. real, public, parameter :: alpha = exp(-delt/tau) real, public, parameter :: eps = 4.e-8 real, public, parameter :: ampv = 1.2e-3/sqrt(tau) real, public, parameter :: ampw = 0. integer, public, parameter :: nfmax = 1200 Functions public  function rang (i) Arguments Type Intent Optional Attributes Name integer :: i Return Value real public  function ranno (i) Arguments Type Intent Optional Attributes Name integer :: i Return Value real public  function ran1 (idum) Arguments Type Intent Optional Attributes Name integer :: idum Return Value real Subroutines public  subroutine force (nzxk, nzyk, nzzk, nttk, gtau, nt) ! specify amplitudes of vort and wave forcing separately\n$                 pk = pk + real(conjg(zx(ikx,iky,ikz)) f1k/wk2)\n$                 pk = pk + real(conjg(zy(ikx,iky,ikz)) f2k/wk2)\n$                 pk = pk + real(conjg(zz(ikx,iky,ikz)) f3k/wk2)\n$                 pp = pp + real(conjg(tt(ikx,iky,ikz)) ftk)*aj/bj Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(iktx,ikty,iktzp) :: nzxk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nzyk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nzzk complex, intent(inout), dimension(iktx,ikty,iktzp) :: nttk complex, intent(inout) :: gtau (1200,4) integer, intent(in) :: nt","tags":"","loc":"module/forcing.html"},{"title":"init_condition – Boussinesq DNS","text":"Uses nm_decomp param_fftw IO_netcdf Variables Type Visibility Attributes Name Initial real, public, parameter :: ki = 8.0 real, public, parameter :: ke_i = 2.0 Subroutines public  subroutine init_cond (zx, zy, zz, tt, uu, vv, ww, ge, g1, g2, zxr, zyr, zzr, ttr, ur, vr, wr, ts) $     ! superpostion of input NetCDF file and user defined fields\n$     ! for user defined fields you can use the functions in this module like single_planewave ...\n$     allocate(zx0(iktx,ikty,iktzp))\n$     allocate(zy0(iktx,ikty,iktzp))\n$     allocate(zz0(iktx,ikty,iktzp))\n$     allocate(tt0(iktx,ikty,iktzp))\n$     call ncreadin(zx,zy,zz,tt,ts)\n$\n$     ! superposing the wave field and background QG\n$     zx = zx + zx0\n$     zy = zy + zy0\n$     zz = zz + zz0\n$     tt = tt + tt0\n$\n$     ! free the memory for auxilliary variables\n$     deallocate(zx0,zy0,zz0,tt0) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt complex, intent(out), dimension(iktx,ikty,iktzp) :: uu complex, intent(out), dimension(iktx,ikty,iktzp) :: vv complex, intent(out), dimension(iktx,ikty,iktzp) :: ww complex, intent(out), dimension(iktx,ikty,iktzp) :: ge complex, intent(out), dimension(iktx,ikty,iktzp) :: g1 complex, intent(out), dimension(iktx,ikty,iktzp) :: g2 real, intent(out), dimension(n1d,n3d,n2dp) :: zxr real, intent(out), dimension(n1d,n3d,n2dp) :: zyr real, intent(out), dimension(n1d,n3d,n2dp) :: zzr real, intent(out), dimension(n1d,n3d,n2dp) :: ttr real, intent(out), dimension(n1d,n3d,n2dp) :: ur real, intent(out), dimension(n1d,n3d,n2dp) :: vr real, intent(out), dimension(n1d,n3d,n2dp) :: wr real, intent(out) :: ts public  subroutine exp_peak (zx, zy, zz, tt, uu, vv, ww, ge, g1, g2) ! Initialize in Fourier space with Gausian peak at ki (defined above) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(iktx,ikty,iktzp) :: zx complex, intent(out), dimension(iktx,ikty,iktzp) :: zy complex, intent(out), dimension(iktx,ikty,iktzp) :: zz complex, intent(out), dimension(iktx,ikty,iktzp) :: tt complex, intent(out), dimension(iktx,ikty,iktzp) :: uu complex, intent(out), dimension(iktx,ikty,iktzp) :: vv complex, intent(out), dimension(iktx,ikty,iktzp) :: ww complex, intent(out), dimension(iktx,ikty,iktzp) :: ge complex, intent(out), dimension(iktx,ikty,iktzp) :: g1 complex, intent(out), dimension(iktx,ikty,iktzp) :: g2 public  subroutine energy_full (zx, zy, zz, tt, ux, uy, uz, ge, g1, g2, ke, pe, eg, ea) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(iktx,ikty,iktzp) :: zx complex, intent(in), dimension(iktx,ikty,iktzp) :: zy complex, intent(in), dimension(iktx,ikty,iktzp) :: zz complex, intent(in), dimension(iktx,ikty,iktzp) :: tt complex, intent(inout), dimension(iktx,ikty,iktzp) :: ux complex, intent(inout), dimension(iktx,ikty,iktzp) :: uy complex, intent(inout), dimension(iktx,ikty,iktzp) :: uz complex, intent(inout), dimension(iktx,ikty,iktzp) :: ge complex, intent(inout), dimension(iktx,ikty,iktzp) :: g1 complex, intent(inout), dimension(iktx,ikty,iktzp) :: g2 real, intent(out) :: ke real, intent(out) :: pe real, intent(out) :: eg real, intent(out) :: ea","tags":"","loc":"module/init_condition.html"},{"title":"MAIN – Boussinesq DNS","text":"Uses param param_fftw velvorproj nm_decomp IO_netcdf init_condition forcing misc diagnostics realspacedumps2 $  if (npts.gt.0) then\n$     allocate(mypoints(npts))\n$     if (tskept<=0) print , 'you forgot to specify the variables to keep in time series'\n$     mypoints = 0\n$     isample = 0\n$     do ic = 1,npts\n$        if ( ( (mype n2dp+1) <= yind(ic) ).and.( yind(ic) <= ((mype+1)*n2dp) ) ) then\n$           mypoints(ic) = 1\n$        endif\n$     end do\n$     nomypts=sum(mypoints)\n$     if (mype.eq.0) allocate(timetseries(nsamples))\n$     if ( (kpU.eq.1).and.(nomypts.gt.0) ) allocate(utseries(nomypts,nsamples))\n$     if ( (kpV.eq.1).and.(nomypts.gt.0) ) allocate(vtseries(nomypts,nsamples))\n$     if ( (kpZZ.eq.1).and.(nomypts.gt.0) ) allocate(zztseries(nomypts,nsamples))\n$  end if $  if (npts.gt.0) then\n$     call dump_timeseries(utseries,vtseries,zztseries,timetseries,mypoints,isample,nomypts)\n$     deallocate(mypoints)\n$     if (mype.eq.0) deallocate(timetseries)\n$     if ( (kpU.eq.1).and.(nomypts.gt.0) ) deallocate(utseries)\n$     if ( (kpV.eq.1).and.(nomypts.gt.0) ) deallocate(vtseries)\n$     if ( (kpZZ.eq.1).and.(nomypts.gt.0) ) deallocate(zztseries)\n$  endif Variables Type Attributes Name Initial real, parameter :: d2 = 2*delt real, parameter :: d12 = delt/12 real, parameter :: k2h = visch*delt real, parameter :: k2z = viscz*delt real, parameter :: v2h = visch*delt real, parameter :: v2z = viscz*delt complex, dimension(:,:,:), pointer :: zxok complex, dimension(:,:,:), pointer :: zyok complex, dimension(:,:,:), pointer :: zzok complex, dimension(:,:,:), pointer :: ttok complex, dimension(:,:,:), pointer :: zxnk complex, dimension(:,:,:), pointer :: zynk complex, dimension(:,:,:), pointer :: zznk complex, dimension(:,:,:), pointer :: ttnk real, dimension(:,:,:), pointer :: zxor real, dimension(:,:,:), pointer :: zyor real, dimension(:,:,:), pointer :: zzor real, dimension(:,:,:), pointer :: ttor real, dimension(:,:,:), pointer :: zxnr real, dimension(:,:,:), pointer :: zynr real, dimension(:,:,:), pointer :: zznr real, dimension(:,:,:), pointer :: ttnr type(C_PTR) :: zxo_p type(C_PTR) :: zyo_p type(C_PTR) :: zzo_p type(C_PTR) :: tto_p type(C_PTR) :: zxn_p type(C_PTR) :: zyn_p type(C_PTR) :: zzn_p type(C_PTR) :: ttn_p complex, dimension(:,:,:), pointer :: nzxk complex, dimension(:,:,:), pointer :: nzyk complex, dimension(:,:,:), pointer :: nzzk complex, dimension(:,:,:), pointer :: nttk complex, dimension(:,:,:), pointer :: uk complex, dimension(:,:,:), pointer :: vk complex, dimension(:,:,:), pointer :: wk real, dimension(:,:,:), pointer :: nzxr real, dimension(:,:,:), pointer :: nzyr real, dimension(:,:,:), pointer :: nzzr real, dimension(:,:,:), pointer :: nttr real, dimension(:,:,:), pointer :: ur real, dimension(:,:,:), pointer :: vr real, dimension(:,:,:), pointer :: wr type(C_PTR) :: nzx_p type(C_PTR) :: nzy_p type(C_PTR) :: nzz_p type(C_PTR) :: ntt_p type(C_PTR) :: u_p type(C_PTR) :: v_p type(C_PTR) :: w_p complex, dimension(:,:,:), allocatable :: rhzx complex, dimension(:,:,:), allocatable :: rhzy complex, dimension(:,:,:), allocatable :: rhzz complex, dimension(:,:,:), allocatable :: rhtt complex, dimension(:,:,:), allocatable :: geok complex, dimension(:,:,:), allocatable :: gw1k complex, dimension(:,:,:), allocatable :: gw2k complex, dimension(:,:,:), allocatable :: zx1k complex, dimension(:,:,:), allocatable :: zy1k complex, dimension(:,:,:), allocatable :: zz1k complex, dimension(:,:,:), allocatable :: tt1k real, dimension(:,:), allocatable :: utseries real, dimension(:,:), allocatable :: vtseries real, dimension(:,:), allocatable :: zztseries real, dimension(:), allocatable :: timetseries integer, dimension(:), allocatable :: mypoints integer :: nomypts complex :: termzx complex :: termzy complex :: termzz complex :: termtt complex :: tzx complex :: tzy complex :: tzz complex :: ttt complex :: u complex :: v complex :: w complex :: c1 complex :: c2 complex :: c3 complex :: gtau (1200,4) real :: dmz real :: dpz real :: r1 real :: r2 real :: kx real :: ky real :: kz real :: kh real :: khn real :: wk2 real :: k real :: ts integer :: ikx integer :: iky integer :: ikz integer :: ikza integer :: ic integer :: isample integer :: iseed integer :: nt = 0 integer :: nt0 integer :: ntdump integer :: npe1 integer :: inrlcount","tags":"","loc":"program/main.html"},{"title":"velvorproj.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module contains the conversion between vorticity and velocity (VELOCITY <--> VORTICITY) !!\nAnd also determines the solenoidal part of vorticity field                                   !!\n-->  Note that vorticity has to solenoindal since it is the curl of velocity                 !!\nThe subroutines in this module: velo, vort, proj                                             !!\nOne of the essential parts of the code that cannot be eliminated even in lightest version    !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module contains the conversion between vorticity and velocity (VELOCITY <--> VORTICITY) !! !! And also determines the solenoidal part of vorticity field                                   !! !! -->  Note that vorticity has to solenoindal since it is the curl of velocity                 !! !! The subroutines in this module: velo, vort, proj                                             !! !! One of the essential parts of the code that cannot be eliminated even in lightest version    !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module velvorproj use param implicit none CONTAINS subroutine velo ( zx , zy , zz , u , v , w ) ! Calculates k-space velocity from k-space vorticity. ! curl (vorticity) = - laplacian (velocity) if velocity is solenoidal. implicit none include 'mpif.h' complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: u , v , w integer :: ikx , iky , ikz , ikza real :: kx , ky , kz , k2 complex :: c1 , c2 , c3 u = cmplx ( 0. , 0. ) v = cmplx ( 0. , 0. ) w = cmplx ( 0. , 0. ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx if ( L ( ikx , iky , ikz ). eq . 1 ) then kx = kxa ( IKX ) k2 = max ( kx * kx + ky * ky + kz * kz , 1.e-15 ) c1 = ky * zz ( ikx , iky , ikz ) - kz * zy ( ikx , iky , ikz ) c2 = kz * zx ( ikx , iky , ikz ) - kx * zz ( ikx , iky , ikz ) c3 = kx * zy ( ikx , iky , ikz ) - ky * zx ( ikx , iky , ikz ) u ( ikx , iky , ikz ) = zi * c1 / k2 v ( ikx , iky , ikz ) = zi * c2 / k2 w ( ikx , iky , ikz ) = zi * c3 / k2 endif enddo enddo enddo return end subroutine velo subroutine vort ( u , v , w , zx , zy , zz ) ! Calculates k-space vortcity from k-space velocity. implicit none include 'mpif.h' complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: u , v , w complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz integer :: ikx , iky , ikz , ikza real :: kx , ky , kz complex :: c1 , c2 , c3 zx = cmplx ( 0. , 0. ) zy = cmplx ( 0. , 0. ) zz = cmplx ( 0. , 0. ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( L ( ikx , iky , ikz ). eq . 1 ) then c1 = ky * w ( ikx , iky , ikz ) - kz * v ( ikx , iky , ikz ) c2 = kz * u ( ikx , iky , ikz ) - kx * w ( ikx , iky , ikz ) c3 = kx * v ( ikx , iky , ikz ) - ky * u ( ikx , iky , ikz ) zx ( ikx , iky , ikz ) = zi * c1 zy ( ikx , iky , ikz ) = zi * c2 zz ( ikx , iky , ikz ) = zi * c3 endif enddo enddo enddo return end subroutine vort subroutine proj ( zx , zy , zz ) ! Fourier-space determination of the solenoidal part of a vector zx,y,z. implicit none include 'mpif.h' complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz integer :: ikx , iky , ikz , ikza real :: kx , ky , kz , k2 complex :: c1 , c2 , c3 do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( L ( ikx , iky , ikz ). eq . 1 ) then k2 = max ( kx * kx + ky * ky + kz * kz , 1.e-15 ) c1 = ( k2 - kx * kx ) * zx ( ikx , iky , ikz ) - kx * ky * zy ( ikx , iky , ikz ) - kx * kz * zz ( ikx , iky , ikz ) c2 = - ky * kx * zx ( ikx , iky , ikz ) + ( k2 - ky * ky ) * zy ( ikx , iky , ikz ) - ky * kz * zz ( ikx , iky , ikz ) c3 = - kz * kx * zx ( ikx , iky , ikz ) - kz * ky * zy ( ikx , iky , ikz ) + ( k2 - kz * kz ) * zz ( ikx , iky , ikz ) zx ( ikx , iky , ikz ) = c1 / k2 zy ( ikx , iky , ikz ) = c2 / k2 zz ( ikx , iky , ikz ) = c3 / k2 endif enddo enddo enddo return end subroutine proj end module velvorproj","tags":"","loc":"sourcefile/velvorproj.f90.html"},{"title":"realspacedumps2.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module dumps subspaces of real (physcial) space in the file 'realspace.ncf'             !!\nAt the moment is limited to 2D slices in physical(real) but can be extended to 3D subsets    !!\nIt can be customised to store one of the fields below                                        !!\nvorticity component, temperature, velocity component                                         !!\nother fields can also be stored                                                              !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module dumps subspaces of real (physcial) space in the file 'realspace.ncf'             !! !! At the moment is limited to 2D slices in physical(real) but can be extended to 3D subsets    !! !! It can be customised to store one of the fields below                                        !! !! vorticity component, temperature, velocity component                                         !! !! other fields can also be stored                                                              !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module realspacedumps2 use param use param_fftw use netcdf use velvorproj use nm_decomp implicit none !! %% PARAMETERs %% integer , parameter :: nHor = FLOOR ( real ( nHend - nHstart + 1.0 , 8 ) / nskipH ) integer , parameter :: nVer = FLOOR ( real ( nVend - nVstart + 1.0 , 8 ) / nskipV ) ! the location of slices integer , parameter :: ihor = n3 / 2 , iver = n1d / 2 ! Here we determine which fields are going to be stored ! Vorticity: ! horizontal slices integer , parameter :: kpZZHtot = 1 , kpZZHbrt = 1 ! vertical slices integer , parameter :: kpZZVtot = 0 , kpZZVbrt = 0 ! Velocities ! horizontal slices integer , parameter :: kpUUHtot = 1 , kpVVHtot = 1 , kpUUHbrc = 1 , kpVVHbrc = 1 ! vertical slices integer , parameter :: kpUUVtot = 0 , kpVVVtot = 0 , kpUUVbrc = 0 , kpVVVbrc = 0 ! Quadratic Nonlinear terms to derive pressure ! horizontal slices integer , parameter :: kpQDHtot = 1 , kpQDHbrt = 1 ! vertical slices integer , parameter :: kpQDVtot = 0 , kpQDVbrt = 0 !! %% VARIABLES %% ! NetCDF IDs integer , save :: idslices , idxrs , idyrs , idzrs , idtmrs , tmrid , xxid , yyid , zzid integer , save :: zzhtotid , zzvtotid , zzhbrtid , zzvbrtid integer , save :: uuhtotid , uuvtotid , vvhtotid , vvvtotid integer , save :: uuhbrcid , uuvbrcid , vvhbrcid , vvvbrcid integer , save :: qdhtotid , qdvtotid , qdhbrtid , qdvbrtid integer , save :: iRScount ! counter when real space fields are dumped !! Make internal variables and functions private PRIVATE :: kpZZHtot , kpZZHbrt , kpZZVtot , kpZZVbrt PRIVATE :: kpUUHtot , kpVVHtot , kpUUHbrc , kpVVHbrc PRIVATE :: kpUUVtot , kpVVVtot , kpUUVbrc , kpVVVbrc PRIVATE :: kpQDHtot , kpQDHbrt , kpQDVtot , kpQDVbrt PRIVATE :: check_rs CONTAINS subroutine check_rs ( sstatus ) implicit none include 'mpif.h' integer , intent ( in ) :: sstatus if ( sstatus /= nf90_noerr ) then print * , 'ERROR in realspacedumps.F90' print * , trim ( nf90_strerror ( sstatus )) call MPI_Abort ( MPI_COMM_WORLD ) end if end subroutine check_rs subroutine prep_realslice () ! creates a netcdf file for slices of fields in real (physical) space. implicit none include 'mpif.h' !!$  real, dimension(nHor):: xr,yr !!$  real, dimension(nVer):: zr real :: xr , yr , zr integer :: ix , iy , iz , ix1 , iy1 , iz1 iRScount = 0 if (( iver . gt . n2 ). or .( ihor . gt . n3 )) then print * , '----------- the slice index out of bound -----------------' endif if ( mod ( n2dp , nskipH ). ne . 0 ) then print * , '----------- cannot handle this skipping: n2dp cannot be divided by nskipH -----------------' endif istatus = nf90_create ( \"realspace.ncf\" , ior ( NF90_NETCDF4 , NF90_MPIIO ), & idslices , comm = MPI_COMM_WORLD , info = MPI_INFO_NULL ) if ( istatus . ne . 0 ) print * , 'Yo! error in creating realspace.ncf! Darn!' ! Define the dimensions of space and time call check_rs ( nf90_def_dim ( idslices , \"xxrs\" , nHor , idxrs )) call check_rs ( nf90_def_dim ( idslices , \"yyrs\" , nHor , idyrs )) call check_rs ( nf90_def_dim ( idslices , \"zzrs\" , nVer , idzrs )) call check_rs ( nf90_def_dim ( idslices , \"timers\" , nrsout + 1 , idtmrs )) ! nsp2dout+ >>1<< for dumping IC ! Define the time variable and spatial coordinates call check_rs ( nf90_def_var ( idslices , \"vartime\" , NF90_FLOAT ,( / idtmrs / ), tmrid )) call check_rs ( nf90_def_var ( idslices , \"varxx\" , NF90_FLOAT ,( / idxrs / ), xxid )) call check_rs ( nf90_def_var ( idslices , \"varyy\" , NF90_FLOAT ,( / idyrs / ), yyid )) call check_rs ( nf90_def_var ( idslices , \"varzz\" , NF90_FLOAT ,( / idzrs / ), zzid )) ! Define the variables for the slices that are supposed to be stored ! i.e. zx, zy, zz and tt if ( kpZZHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), zzhtotid ) endif if ( kpZZVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), zzvtotid ) endif if ( kpZZHbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZHbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), zzhbrtid ) endif if ( kpZZVbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZVbrt\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), zzvbrtid ) endif if ( kpUUHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhtotid ) endif if ( kpUUVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), uuvtotid ) endif if ( kpVVHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhtotid ) endif if ( kpVVVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), vvvtotid ) endif if ( kpUUHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhbrcid ) endif if ( kpUUVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUVbrc\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), uuvbrcid ) endif if ( kpVVHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhbrcid ) endif if ( kpVVVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVVbrc\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), vvvbrcid ) endif if ( kpQDHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdhtotid ) endif if ( kpQDVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDVtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdvtotid ) endif if ( kpQDHbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDHbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdhbrtid ) endif if ( kpQDVbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDVbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdvbrtid ) endif call check_rs ( nf90_enddef ( idslices ) ) ! put values in spatial coordinate variables i.e. varxx and varyy vectors if ( mype . eq . 0 ) then ix1 = 0 iy1 = 0 iz1 = 0 do ix = nHstart , nHend , nskipH ix1 = ix1 + 1 xr = ( real ( ix ) - 1.0 ) / ( real ( n1 ) - 1.0 ) * L1 - L1 / 2.0 istatus = nf90_put_var ( idslices , xxid , xr , start = ( / ix1 / )) if ( istatus . ne . 0 ) print * , 'Yo! we fucked up xr! Darn!' enddo do iy = nHstart , nHend , nskipH iy1 = iy1 + 1 yr = ( real ( iy ) - 1.0 ) / ( real ( n2d ) - 1.0 ) * L2 - L2 / 2.0 call check_rs ( nf90_put_var ( idslices , yyid , yr , start = ( / iy1 / )) ) enddo do iz = nVstart , nVend , nskipV iz1 = iz1 + 1 zr = ( real ( iz ) - 1.0 ) / ( real ( n3d ) - 1.0 ) * L3 - L3 / 2.0 call check_rs ( nf90_put_var ( idslices , zzid , zr , start = ( / iz1 / )) ) enddo endif return end subroutine prep_realslice subroutine dump_realspace ( zxk , zyk , zzk , ttk , uk , vk , wk , zxr , zyr , zzr , ttr , ur , vr , wr ) implicit none include 'mpif.h' real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr , ur , vr , wr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zxk , zyk , zzk , ttk , uk , vk , wk complex , dimension ( iktx , ikty , iktzp ) :: zxaux , zyaux , zzaux , ttaux , qdk integer :: ikz , ikza real :: kz iRScount = iRScount + 1 if ( mype . eq . 0 ) istatus = nf90_put_var ( idslices , tmrid , time , start = ( / iRScount / )) qdk = cmplx ( 0. , 0. ) zzaux = zzk zxaux = zxk zyaux = zyk ttaux = ttk call fftwkr ( plan3_zznk_zznr , zzk , zzr ) call dump_horslice ( zzr , zzhtotid ) call dump_verslice ( zzr , zzvtotid ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) ! First store the total velocities call velo ( zxk , zyk , zzk , uk , vk , wk ) call fftwkr ( plan3_uk_ur , uk , ur ) call dump_horslice ( ur , uuhtotid ) call dump_verslice ( ur , uuvtotid ) zxr = ur call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) call dump_horslice ( vr , vvhtotid ) call dump_verslice ( vr , vvvtotid ) zyr = vr call fftwrk ( plan3_vr_vk , vr , vk ) ! Derive the quadratic nonlinear terms for calculating pressure (using total vel.) ttr = zxr * zxr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- kx * kx * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) qdk = qdk + ttk ttr = zxr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- kx * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) qdk = qdk + ttk ttr = zyr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- ky * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) qdk = qdk + ttk ttk = qdk call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) call dump_horslice ( ttr , qdhtotid ) call dump_verslice ( ttr , qdvtotid ) ! Derive the baroclinic velocities and store them do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) if ( abs ( kz ). lt . 1e-4 ) then uk (:,:, ikz ) = cmplx ( 0. , 0. ) vk (:,:, ikz ) = cmplx ( 0. , 0. ) wk (:,:, ikz ) = cmplx ( 0. , 0. ) else zzk (:,:, ikz ) = cmplx ( 0. , 0. ) endif enddo call fftwkr ( plan3_zznk_zznr , zzk , zzr ) call dump_horslice ( zzr , zzhbrtid ) call dump_verslice ( zzr , zzvbrtid ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) call fftwkr ( plan3_uk_ur , uk , ur ) call dump_horslice ( ur , uuhbrcid ) call dump_verslice ( ur , uuvbrcid ) call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) call dump_horslice ( vr , vvhbrcid ) call dump_verslice ( vr , vvvbrcid ) call fftwrk ( plan3_vr_vk , vr , vk ) zzk = zzaux zxk = zxaux zyk = zyaux ttk = ttaux ! Derive the quadratic nonlinear terms for calculating pressure (using barotropic vel.) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) if ( abs ( kz ). lt . 1e-4 ) then uk (:,:, ikz ) = cmplx ( 0. , 0. ) vk (:,:, ikz ) = cmplx ( 0. , 0. ) wk (:,:, ikz ) = cmplx ( 0. , 0. ) else zzk (:,:, ikz ) = cmplx ( 0. , 0. ) endif enddo return end subroutine dump_realspace subroutine dump_horslice ( fr , idhvar ) implicit none include 'mpif.h' real , intent ( in ), dimension ( n1d , n3d , n2dp ) :: fr real , dimension ( n1d , n2dp ) :: frslice , junk real , dimension ( n1d , n2d ) :: horvars integer , intent ( in ) :: idhvar integer , dimension ( 3 ) :: nccount , ncstart integer :: k , nsends , nbuf , iproc , istart integer :: status ( MPI_STATUS_SIZE ) nsends = npe - 1 do k = 1 , n2dp frslice (:, k ) = fr (:, ihor , k ) enddo nbuf = n1d * n2dp if ( mype . gt . 0 ) then call mpi_send ( frslice , nbuf , MPI_REAL , 0 , 137 , MPI_COMM_WORLD , istatus ) endif if ( mype . eq . 0 ) then horvars ( 1 : n1d , 1 : n2dp ) = frslice do iproc = 1 , nsends call mpi_recv ( junk , nbuf , MPI_REAL , MPI_ANY_SOURCE , 137 , MPI_COMM_WORLD , status , istatus ) istart = status ( MPI_SOURCE ) * n2dp do k = 1 , n2dp horvars ( 1 : n1d , istart + k ) = junk ( 1 : n1d , k ) enddo enddo ! print*, 'horvars(384,384) = ', horvars(384,384) call check_rs ( nf90_put_var ( idslices , idhvar , & horvars ( nHstart + 1 : nHend + 1 : nskipH , nHstart + 1 : nHend + 1 : nskipH ), & start = ( / 1 , 1 , iRScount / ), count = ( / nHor , nHor , 1 / ))) endif end subroutine dump_horslice subroutine dump_verslice ( fr , idvvar ) implicit none include 'mpif.h' real , intent ( in ), dimension ( n1d , n3d , n2dp ) :: fr integer , intent ( in ) :: idvvar real , dimension ( nHor , nVer ) :: vervars integer :: wantedmype , ix , iz , ix1 , iz1 wantedmype = floor (( iver - 1.0 ) / n2dp ) if ( wantedmype . eq . mype ) then iz1 = 0 do iz = nVstart , nVend , nskipV iz1 = iz1 + 1 ix1 = 0 do ix = nHstart + 1 , nHend + 1 , nskipH ix1 = ix1 + 1 vervars ( ix1 , iz1 ) = fr ( ix , iz , iver - wantedmype * n2dp ) end do end do call check_rs ( nf90_put_var ( idslices , idvvar , vervars , & start = ( / 1 , 1 , iRScount / ), count = ( / nHor , nVer , 1 / ))) endif end subroutine dump_verslice subroutine close_ncf_realspace () ! close creates a netcdf file for real space dumping implicit none include 'mpif.h' call check_rs ( nf90_close ( idslices ) ) return end subroutine close_ncf_realspace end module realspacedumps2","tags":"","loc":"sourcefile/realspacedumps2.f90.html"},{"title":"nm_decomp.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module contains Normal Mode Decomposition as described in Bartello, 1995                !!\nThe subroutines in this module: wtoab, atowb                                                 !!\nModules used : param.F90 and velvorproj.F90                                                  !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module contains Normal Mode Decomposition as described in Bartello, 1995                !! !! The subroutines in this module: wtoab, atowb                                                 !! !! Modules used : param.F90 and velvorproj.F90                                                  !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module nm_decomp !  use param use velvorproj implicit none CONTAINS subroutine wtoab ( zx , zy , zz , tt , geok , gw1k , gw2k , u , v , w ) ! Converts from (vorticity, buoyancy) to (geok,grav.wave_1k,grav.wave_2k) implicit none complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: u , v , w complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: geok , gw1k , gw2k integer :: ikx , iky , ikz , ikza , ikz0 real :: omega , norm real :: wkh , wkh2 , kx , ky , kz , wk , wk2 , wkhn complex :: div , zk , tk , dk , bk geok = cmplx ( 0. , 0. ) gw1k = cmplx ( 0. , 0. ) gw2k = cmplx ( 0. , 0. ) call velo ( zx , zy , zz , u , v , w ) if ( mype . eq . 0 ) then ikz0 = 2 else ikz0 = 1 endif do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wkh2 = kx * kx + ky * ky wkh = sqrt ( wkh2 ) wkhn = wkh * L1 / twopi if ( wkhn . lt . 1.e-10 ) then geok ( ikx , iky , ikz0 : iktzp ) = aj * tt ( ikx , iky , ikz0 : iktzp ) gw1k ( ikx , iky , ikz0 : iktzp ) = u ( ikx , iky , ikz0 : iktzp ) - zi * v ( ikx , iky , ikz0 : iktzp ) gw2k ( ikx , iky , ikz0 : iktzp ) = u ( ikx , iky , ikz0 : iktzp ) + zi * v ( ikx , iky , ikz0 : iktzp ) else do ikz = ikz0 , iktzp if ( L ( ikx , iky , ikz ). eq . 1 ) then ikza = mype * iktzp + ikz kz = kza ( ikza ) wk2 = wkh2 + kz * kz wk = sqrt ( wk2 ) wk = max ( wk , 1.e-15 ) omega = sqrt ( cor2 * kz * kz + bf2 * wkh2 ) / wk div = zi * ( kx * u ( ikx , iky , ikz ) + ky * v ( ikx , iky , ikz )) bk = aj * tt ( ikx , iky , ikz ) zk = zz ( ikx , iky , ikz ) dk = ( wk / kz ) * div tk = ( wkh / bf ) * bk norm = omega * wk geok ( ikx , iky , ikz ) = ( bf * wkh * zk + zi * cor * kz * tk ) / norm norm = sqrt2 * omega * wk gw1k ( ikx , iky , ikz ) = ( - zi * cor * kz * zk + omega * wk * dk - bf * wkh * tk ) / norm norm = sqrt2 * omega * wk gw2k ( ikx , iky , ikz ) = ( + zi * cor * kz * zk + omega * wk * dk + bf * wkh * tk ) / norm endif enddo endif enddo enddo if ( mype . eq . 0 ) then ! do kz=0 modes do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( L ( ikx , iky , 1 ). eq . 1 ) then bk = aj * tt ( ikx , iky , 1 ) geok ( ikx , iky , 1 ) = zz ( ikx , iky , 1 ) gw1k ( ikx , iky , 1 ) = w ( ikx , iky , 1 ) - zi * bk / bf gw2k ( ikx , iky , 1 ) = w ( ikx , iky , 1 ) + zi * bk / bf endif enddo enddo endif return end subroutine wtoab subroutine atowb ( geok , gw1k , gw2k , zx , zy , zz , tt , u , v , w ) ! Converts from (geok,grav.wave_1k,grav.wave_2k) to (zeta,d,t). implicit none complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: geok , gw1k , gw2k complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: u , v , w complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt integer :: ikx , iky , ikz , ikz0 , ikza real :: omega real :: wkh , wkh2 , kx , ky , kz , wk , wk2 , wkhn complex :: zk , dk , tk , bk , gn , psi , div complex :: zgk , z1k , z2k , dgk , d1k , d2k , tgk , t1k , t2k u = cmplx ( 0. , 0. ) v = cmplx ( 0. , 0. ) w = cmplx ( 0. , 0. ) tt = cmplx ( 0. , 0. ) zx = cmplx ( 0. , 0. ) zy = cmplx ( 0. , 0. ) zz = cmplx ( 0. , 0. ) if ( mype . eq . 0 ) then ikz0 = 2 else ikz0 = 1 endif do ikz = ikz0 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wkh2 = kx * kx + ky * ky wkh = sqrt ( wkh2 ) wkhn = wkh * L1 / twopi if ( L ( ikx , iky , ikz ). eq . 1 ) then wk2 = wkh2 + kz * kz wk = sqrt ( wk2 ) wk = max ( wk , 1.e-15 ) omega = sqrt ( cor2 * kz * kz + bf2 * wkh2 ) / wk gn = geok ( ikx , iky , ikz ) / ( omega * wk ) zgk = bf * wkh * gn dgk = cmplx ( 0. , 0. ) tgk = - zi * cor * kz * gn gn = gw1k ( ikx , iky , ikz ) / ( sqrt2 * omega * wk ) z1k = + zi * cor * kz * gn d1k = omega * wk * gn t1k = - bf * wkh * gn gn = gw2k ( ikx , iky , ikz ) / ( sqrt2 * omega * wk ) z2k = - zi * cor * kz * gn d2k = omega * wk * gn t2k = + bf * wkh * gn zk = zgk + z1k + z2k dk = dgk + d1k + d2k tk = tgk + t1k + t2k if ( wkhn . gt . 1.e-10 ) then div = dk * kz / wk u ( ikx , iky , ikz ) = + zi * ( ky * zk - kx * div ) / wkh2 v ( ikx , iky , ikz ) = - zi * ( kx * zk + ky * div ) / wkh2 w ( ikx , iky , ikz ) = zi * div / kz tt ( ikx , iky , ikz ) = bf * tk / ( aj * wkh ) else u ( ikx , iky , ikz ) = 0.5 * ( gw1k ( ikx , iky , ikz ) + gw2k ( ikx , iky , ikz )) v ( ikx , iky , ikz ) = - zi * 0.5 * ( gw1k ( ikx , iky , ikz ) - gw2k ( ikx , iky , ikz )) w ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) tt ( ikx , iky , ikz ) = geok ( ikx , iky , ikz ) / aj endif endif enddo enddo enddo if ( mype . eq . 0 ) then ! do kz=0 modes do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( L ( ikx , iky , 1 ). eq . 1 ) then psi = - geok ( ikx , iky , 1 ) / ( kx * kx + ky * ky ) u ( ikx , iky , 1 ) = - zi * ky * psi v ( ikx , iky , 1 ) = + zi * kx * psi w ( ikx , iky , 1 ) = 0.5 * ( gw1k ( ikx , iky , 1 ) + gw2k ( ikx , iky , 1 )) bk = zi * bf * 0.5 * ( gw1k ( ikx , iky , 1 ) - gw2k ( ikx , iky , 1 )) tt ( ikx , iky , 1 ) = bk / aj endif enddo enddo endif call vort ( u , v , w , zx , zy , zz ) return end subroutine atowb end module nm_decomp","tags":"","loc":"sourcefile/nm_decomp.f90.html"},{"title":"realspacedumpsPressure.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module dumps subspaces of real (physcial) space in the file 'realspace.ncf'             !!\nAt the moment is limited to 2D slices in physical(real) but can be extended to 3D subsets    !!\nIt can be customised to store one of the fields below                                        !!\nvorticity component, temperature, velocity component                                         !!\nother fields can also be stored                                                              !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module dumps subspaces of real (physcial) space in the file 'realspace.ncf'             !! !! At the moment is limited to 2D slices in physical(real) but can be extended to 3D subsets    !! !! It can be customised to store one of the fields below                                        !! !! vorticity component, temperature, velocity component                                         !! !! other fields can also be stored                                                              !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module realspacedumps2 use param use param_fftw use netcdf use velvorproj use nm_decomp implicit none !! %% PARAMETERs %% integer , parameter :: nHor = FLOOR ( real ( nHend - nHstart + 1.0 , 8 ) / nskipH ) integer , parameter :: nVer = FLOOR ( real ( nVend - nVstart + 1.0 , 8 ) / nskipV ) ! the location of slices integer , parameter :: ihor = n3 / 2 , iver = n1d / 2 ! Here we determine which fields are going to be stored ! Vorticity: ! horizontal slices integer , parameter :: kpZZHtot = 1 , kpZZHbrt = 1 ! vertical slices integer , parameter :: kpZZVtot = 1 , kpZZVbrt = 1 ! Velocities ! horizontal slices integer , parameter :: kpUUHtot = 1 , kpVVHtot = 1 , kpUUHbrc = 1 , kpVVHbrc = 1 ! vertical slices integer , parameter :: kpUUVtot = 1 , kpVVVtot = 1 , kpUUVbrc = 1 , kpVVVbrc = 1 ! Quadratic Nonlinear terms to derive pressure ! horizontal slices integer , parameter :: kpQDHtot = 1 , kpQDHbrc = 1 ! vertical slices integer , parameter :: kpQDVtot = 1 , kpQDVbrc = 1 !! %% VARIABLES %% ! NetCDF IDs integer , save :: idslices , idxrs , idyrs , idzrs , idtmrs , tmrid , xxid , yyid , zzid integer , save :: zzhtotid , zzvtotid , zzhbrtid , zzvbrtid integer , save :: uuhtotid , uuvtotid , vvhtotid , vvvtotid integer , save :: uuhbrcid , uuvbrcid , vvhbrcid , vvvbrcid integer , save :: qdhtotid , qdvtotid , qdhbrcid , qdvbrcid integer , save :: iRScount ! counter when real space fields are dumped !! Make internal variables and functions private PRIVATE :: kpZZHtot , kpZZHbrt , kpZZVtot , kpZZVbrt PRIVATE :: kpUUHtot , kpVVHtot , kpUUHbrc , kpVVHbrc PRIVATE :: kpUUVtot , kpVVVtot , kpUUVbrc , kpVVVbrc PRIVATE :: kpQDHtot , kpQDHbrc , kpQDVtot , kpQDVbrc PRIVATE :: check_rs CONTAINS subroutine check_rs ( sstatus ) implicit none include 'mpif.h' integer , intent ( in ) :: sstatus if ( sstatus /= nf90_noerr ) then print * , 'ERROR in realspacedumps.F90' print * , trim ( nf90_strerror ( sstatus )) call MPI_Abort ( MPI_COMM_WORLD ) end if end subroutine check_rs subroutine prep_realslice () ! creates a netcdf file for slices of fields in real (physical) space. implicit none include 'mpif.h' !!$  real, dimension(nHor):: xr,yr !!$  real, dimension(nVer):: zr real :: xr , yr , zr integer :: ix , iy , iz , ix1 , iy1 , iz1 iRScount = 0 if (( iver . gt . n2 ). or .( ihor . gt . n3 )) then print * , '----------- the slice index out of bound -----------------' endif if ( mod ( n2dp , nskipH ). ne . 0 ) then print * , '----------- cannot handle this skipping: n2dp cannot be divided by nskipH -----------------' endif istatus = nf90_create ( \"realspace.ncf\" , ior ( NF90_NETCDF4 , NF90_MPIIO ), & idslices , comm = MPI_COMM_WORLD , info = MPI_INFO_NULL ) if ( istatus . ne . 0 ) print * , 'Yo! error in creating realspace.ncf! Darn!' ! Define the dimensions of space and time call check_rs ( nf90_def_dim ( idslices , \"xxrs\" , nHor , idxrs )) call check_rs ( nf90_def_dim ( idslices , \"yyrs\" , nHor , idyrs )) call check_rs ( nf90_def_dim ( idslices , \"zzrs\" , nVer , idzrs )) call check_rs ( nf90_def_dim ( idslices , \"timers\" , nrsout + 1 , idtmrs )) ! nsp2dout+ >>1<< for dumping IC ! Define the time variable and spatial coordinates call check_rs ( nf90_def_var ( idslices , \"vartime\" , NF90_FLOAT ,( / idtmrs / ), tmrid )) call check_rs ( nf90_def_var ( idslices , \"varxx\" , NF90_FLOAT ,( / idxrs / ), xxid )) call check_rs ( nf90_def_var ( idslices , \"varyy\" , NF90_FLOAT ,( / idyrs / ), yyid )) call check_rs ( nf90_def_var ( idslices , \"varzz\" , NF90_FLOAT ,( / idzrs / ), zzid )) ! Define the variables for the slices that are supposed to be stored ! i.e. zx, zy, zz and tt if ( kpZZHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), zzhtotid ) endif if ( kpZZVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), zzvtotid ) endif if ( kpZZHbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZHbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), zzhbrtid ) endif if ( kpZZVbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZVbrt\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), zzvbrtid ) endif if ( kpUUHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhtotid ) endif if ( kpUUVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), uuvtotid ) endif if ( kpVVHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhtotid ) endif if ( kpVVVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), vvvtotid ) endif if ( kpUUHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhbrcid ) endif if ( kpUUVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUVbrc\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), uuvbrcid ) endif if ( kpVVHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhbrcid ) endif if ( kpVVVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVVbrc\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), vvvbrcid ) endif if ( kpQDHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdhtotid ) endif if ( kpQDVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDVtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdvtotid ) endif if ( kpQDHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdhbrcid ) endif if ( kpQDVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDVbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdvbrcid ) endif call check_rs ( nf90_enddef ( idslices ) ) ! put values in spatial coordinate variables i.e. varxx and varyy vectors if ( mype . eq . 0 ) then ix1 = 0 iy1 = 0 iz1 = 0 do ix = nHstart , nHend , nskipH ix1 = ix1 + 1 xr = ( real ( ix ) - 1.0 ) / ( real ( n1 ) - 1.0 ) * L1 - L1 / 2.0 istatus = nf90_put_var ( idslices , xxid , xr , start = ( / ix1 / )) if ( istatus . ne . 0 ) print * , 'Yo! we fucked up xr! Darn!' enddo do iy = nHstart , nHend , nskipH iy1 = iy1 + 1 yr = ( real ( iy ) - 1.0 ) / ( real ( n2d ) - 1.0 ) * L2 - L2 / 2.0 call check_rs ( nf90_put_var ( idslices , yyid , yr , start = ( / iy1 / )) ) enddo do iz = nVstart , nVend , nskipV iz1 = iz1 + 1 zr = ( real ( iz ) - 1.0 ) / ( real ( n3d ) - 1.0 ) * L3 - L3 / 2.0 call check_rs ( nf90_put_var ( idslices , zzid , zr , start = ( / iz1 / )) ) enddo endif return end subroutine prep_realslice subroutine dump_realspace ( zxk , zyk , zzk , ttk , uk , vk , wk , zxr , zyr , zzr , ttr , ur , vr , wr ) implicit none include 'mpif.h' real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr , ur , vr , wr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zxk , zyk , zzk , ttk , uk , vk , wk complex , dimension ( iktx , ikty , iktzp ) :: zxaux , zyaux , zzaux , ttaux , qdk integer :: ikz , ikza , ikx , iky real :: kz , kx , ky iRScount = iRScount + 1 if ( mype . eq . 0 ) istatus = nf90_put_var ( idslices , tmrid , time , start = ( / iRScount / )) zzaux = zzk zxaux = zxk zyaux = zyk ttaux = ttk call fftwkr ( plan3_zznk_zznr , zzk , zzr ) if ( kpZZHtot . eq . 1 ) call dump_horslice ( zzr , zzhtotid ) if ( kpZZVtot . eq . 1 ) call dump_verslice ( zzr , zzvtotid ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) ! First store the total velocities call velo ( zxk , zyk , zzk , uk , vk , wk ) call fftwkr ( plan3_uk_ur , uk , ur ) if ( kpUUHtot . eq . 1 ) call dump_horslice ( ur , uuhtotid ) if ( kpUUVtot . eq . 1 ) call dump_verslice ( ur , uuvtotid ) zxr = ur call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) if ( kpVVHtot . eq . 1 ) call dump_horslice ( vr , vvhtotid ) if ( kpVVVtot . eq . 1 ) call dump_verslice ( vr , vvvtotid ) zyr = vr call fftwrk ( plan3_vr_vk , vr , vk ) ! Derive the quadratic nonlinear terms for calculating pressure (using total vel.) qdk = cmplx ( 0. , 0. ) ttr = zxr * zxr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- kx * kx * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttr = zxr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- 2 * kx * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttr = zyr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- ky * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttk = qdk call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) if ( kpQDHtot . eq . 1 ) call dump_horslice ( ttr , qdhtotid ) if ( kpQDVtot . eq . 1 ) call dump_verslice ( ttr , qdvtotid ) zxk = cmplx ( 0. , 0. ) zyk = cmplx ( 0. , 0. ) ! Derive the baroclinic velocities and store them do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then uk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) vk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) else zzk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo call fftwkr ( plan3_zznk_zznr , zzk , zzr ) if ( kpZZHbrt . eq . 1 ) call dump_horslice ( zzr , zzhbrtid ) if ( kpZZVbrt . eq . 1 ) call dump_verslice ( zzr , zzvbrtid ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) call fftwkr ( plan3_uk_ur , uk , ur ) if ( kpUUHbrc . eq . 1 ) call dump_horslice ( ur , uuhbrcid ) if ( kpUUVbrc . eq . 1 ) call dump_verslice ( ur , uuvbrcid ) call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) if ( kpVVHbrc . eq . 1 ) call dump_horslice ( vr , vvhbrcid ) if ( kpVVVbrc . eq . 1 ) call dump_verslice ( vr , vvvbrcid ) call fftwrk ( plan3_vr_vk , vr , vk ) ! Derive the quadratic nonlinear terms for calculating pressure (using barotropic vel.) zxk = uk zyk = vk call fftwkr ( plan3_zxnk_zxnr , zxk , zxr ) call fftwkr ( plan3_zynk_zynr , zyk , zyr ) qdk = cmplx ( 0. , 0. ) ttr = zxr * zxr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- kx * kx * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttr = zxr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- 2 * kx * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttr = zyr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- ky * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttk = qdk call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) if ( kpQDHbrc . eq . 1 ) call dump_horslice ( ttr , qdhbrcid ) if ( kpQDVbrc . eq . 1 ) call dump_verslice ( ttr , qdvbrcid ) zzk = zzaux zxk = zxaux zyk = zyaux ttk = ttaux return end subroutine dump_realspace subroutine dump_horslice ( fr , idhvar ) implicit none include 'mpif.h' real , intent ( in ), dimension ( n1d , n3d , n2dp ) :: fr real , dimension ( n1d , n2dp ) :: frslice , junk real , dimension ( n1d , n2d ) :: horvars integer , intent ( in ) :: idhvar integer , dimension ( 3 ) :: nccount , ncstart integer :: k , nsends , nbuf , iproc , istart integer :: status ( MPI_STATUS_SIZE ) nsends = npe - 1 do k = 1 , n2dp frslice (:, k ) = fr (:, ihor , k ) enddo nbuf = n1d * n2dp if ( mype . gt . 0 ) then call mpi_send ( frslice , nbuf , MPI_REAL , 0 , 137 , MPI_COMM_WORLD , istatus ) endif if ( mype . eq . 0 ) then horvars ( 1 : n1d , 1 : n2dp ) = frslice do iproc = 1 , nsends call mpi_recv ( junk , nbuf , MPI_REAL , MPI_ANY_SOURCE , 137 , MPI_COMM_WORLD , status , istatus ) istart = status ( MPI_SOURCE ) * n2dp do k = 1 , n2dp horvars ( 1 : n1d , istart + k ) = junk ( 1 : n1d , k ) enddo enddo ! print*, 'horvars(384,384) = ', horvars(384,384) call check_rs ( nf90_put_var ( idslices , idhvar , & horvars ( nHstart + 1 : nHend + 1 : nskipH , nHstart + 1 : nHend + 1 : nskipH ), & start = ( / 1 , 1 , iRScount / ), count = ( / nHor , nHor , 1 / ))) endif end subroutine dump_horslice subroutine dump_verslice ( fr , idvvar ) implicit none include 'mpif.h' real , intent ( in ), dimension ( n1d , n3d , n2dp ) :: fr integer , intent ( in ) :: idvvar real , dimension ( nHor , nVer ) :: vervars integer :: wantedmype , ix , iz , ix1 , iz1 wantedmype = floor (( iver - 1.0 ) / n2dp ) if ( wantedmype . eq . mype ) then iz1 = 0 do iz = nVstart , nVend , nskipV iz1 = iz1 + 1 ix1 = 0 do ix = nHstart + 1 , nHend + 1 , nskipH ix1 = ix1 + 1 vervars ( ix1 , iz1 ) = fr ( ix , iz , iver - wantedmype * n2dp ) end do end do call check_rs ( nf90_put_var ( idslices , idvvar , vervars , & start = ( / 1 , 1 , iRScount / ), count = ( / nHor , nVer , 1 / ))) endif end subroutine dump_verslice subroutine close_ncf_realspace () ! close creates a netcdf file for real space dumping implicit none include 'mpif.h' call check_rs ( nf90_close ( idslices ) ) return end subroutine close_ncf_realspace end module realspacedumps2","tags":"","loc":"sourcefile/realspacedumpspressure.f90.html"},{"title":"diagnostics.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!\nThis module contains the diagnostics such as eng time series, energy and transfer spectra    !!\nas well as outputing run.list                                                                !!\nOne of the essential parts of the code that cannot be eliminated even in the lightest version!!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!! !! This module contains the diagnostics such as eng time series, energy and transfer spectra    !! !! as well as outputing run.list                                                                !! !! One of the essential parts of the code that cannot be eliminated even in the lightest version!! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!! module diagnostics !  use param !  use velvorproj use nm_decomp implicit none !! Wether or not keep eng.dat (time series of energys) or eps.dat (time series of dissipations) integer , parameter :: keepENG = 1 , keepEPS = 0 !! ID for energy time series (eng.dat) and dissipation (eps.dat) integer , parameter :: iuENG = 41 , iuEPS = 42 !! which ENERGY SPECTRA to keep: !! SPCH: horizontal energy spectra, SPCZ: vertical eng spectra, SPC: spherical eng spectra integer , parameter :: keepSPCH = 1 , keepSPCZ = 1 , keepSPC = 0 !! which TRANSFER SPECTRA to keep: integer , parameter :: keepTRNH = 1 , keepTRNZ = 1 , keepTRN = 0 !! A flag for decomposing the wave energy and transfers to potential and kinetic parts !! it is costly (both memory & computation) --> avoid it if not necessary for analysis integer , parameter :: potkinwv_flag = 0 !! Triad Transfers: if triad transfers (GG->G, GA->G, AA-> G and ... ) are need turn it on! integer , parameter :: triads_on = 0 !! the file IDs of each type of spectra integer , parameter :: iuTRNH = 71 , iuTRNZ = 72 , iuTRN = 73 !! the file IDs of each type of spectra integer , parameter :: iuSPCH = 51 , iuSPCZ = 52 , iuSPC = 53 ! Make internal variables and functions private PRIVATE :: keepSPCH , keepSPCZ , keepSPC , keepTRNH , keepTRNZ , keepTRN , potkinwv_flag , triads_on !PRIVATE :: iuSPCH,iuSPCZ,iuSPC,iuTRNH,iuTRNZ,iuTRN CONTAINS subroutine prep_diagnostics () ! Open the binary (formatted) files for energy spectra, transfers, energy time series and ... implicit none include 'mpif.h' if ( mype . eq . 0 ) then if ( keepENG == 1 ) open ( iuENG , file = 'eng.dat' , form = 'formatted' ) if ( keepEPS == 1 ) open ( iuEPS , file = 'eps.dat' , form = 'formatted' ) if ( keepSPCH == 1 ) open ( iuSPCH , file = 'spch.dat' , form = 'formatted' ) if ( keepSPCZ == 1 ) open ( iuSPCZ , file = 'spcz.dat' , form = 'formatted' ) if ( keepSPC == 1 ) open ( iuSPC , file = 'spc.dat' , form = 'formatted' ) if ( keepTRNH == 1 ) open ( iuTRNH , file = 'trnh.dat' , form = 'formatted' ) if ( keepTRNZ == 1 ) open ( iuTRNZ , file = 'trnz.dat' , form = 'formatted' ) if ( keepTRN == 1 ) open ( iuTRN , file = 'trn.dat' , form = 'formatted' ) endif return end subroutine prep_diagnostics subroutine out_eng ( zx , zy , zz , tt , ux , uy , uz , ge , g1 , g2 , zxwv , zywv , zzwv , ttwv , nt ) !! prints the energies and flow parameters in an output file (e.g. \"run.list\") !! also dumps the energies and dissipations as function of time in 'eng.dat' and 'eps.dat' !! Note: zx,zy,zz,tt,ge,g1,g2 would not change in this subroutine but !! ux,uy,uz,zxwv,zywv,zzwv,ttwv do change !! usually rhzx,rhzy,rhzz are used for zxwv,zywv,zzwv,ttwv to save memory !! Hence, pay attention when using \"uk,vk,wk,nttk,rhzx,rhzy,rhzz\" implicit none include 'mpif.h' integer , intent ( in ) :: nt complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt , ge , g1 , g2 complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: ux , uy , uz , zxwv , zywv , zzwv , ttwv complex , dimension (:,:,:), allocatable :: gewv integer :: ikx , iky , ikz , ikza real :: kx , ky , kz , wk2 , wkh2 , wkh2n , kzn real :: vh , vzx , vzy , vzz , zzx , zzy , zzz real :: rms_verv , rms_horv , rossby , fr_z , fr_h , ke , pe , e , eg , ea real :: epsk , epsp , eps , epskh , epskv , epsph , epspv , tmp real :: zero_kz_geo , zero_kz_grv , zero_kh_grv , zero_kh_geo , pewv , kewv , scaletime if ( potkinwv_flag == 1 ) then allocate ( gewv ( iktx , ikty , iktzp )) endif call velo ( zx , zy , zz , ux , uy , uz ) rms_verv = 0. rms_horv = 0. zero_kz_geo = 0. zero_kz_grv = 0. zero_kh_geo = 0. zero_kh_grv = 0. ke = 0. pe = 0. eg = 0. ea = 0. epsk = 0. epsp = 0. epskh = 0. epsph = 0. epskv = 0. epspv = 0. eps = 0. do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) kzn = kz * ( L3 / twopi ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wkh2 = kx * kx + ky * ky wk2 = kx * kx + ky * ky + kz * kz if ( L ( ikx , iky , ikz ). eq . 1 ) then wkh2n = wkh2 * ( L1 / twopi ) ** 2 zzx = real ( zx ( ikx , iky , ikz ) * conjg ( zx ( ikx , iky , ikz ))) zzy = real ( zy ( ikx , iky , ikz ) * conjg ( zy ( ikx , iky , ikz ))) zzz = real ( zz ( ikx , iky , ikz ) * conjg ( zz ( ikx , iky , ikz ))) vzx = real ( ux ( ikx , iky , ikz ) * conjg ( ux ( ikx , iky , ikz ))) vzy = real ( uy ( ikx , iky , ikz ) * conjg ( uy ( ikx , iky , ikz ))) vzz = real ( uz ( ikx , iky , ikz ) * conjg ( uz ( ikx , iky , ikz ))) vh = real ( tt ( ikx , iky , ikz ) * conjg ( tt ( ikx , iky , ikz ))) ke = ke + ( zzx + zzy + zzz ) / wk2 pe = pe + vh rms_verv = rms_verv + zzz rms_horv = rms_horv + zzx + zzy if ( keepEPS == 1 ) then epsk = epsk + ( visch * wkh2 ** ilap + viscz * kz ** ( 2 * ilap )) * ( vzx + vzy + vzz ) epskh = epskh + ( visch * wkh2 ** ilap ) * ( vzx + vzy + vzz ) epskv = epskv + ( viscz * kz ** ( 2 * ilap )) * ( vzx + vzy + vzz ) epsp = epsp + ( visch * wkh2 ** ilap + viscz * kz ** ( 2 * ilap )) * vh * aj / bj epsph = epsph + ( visch * wkh2 ** ilap ) * vh * aj / bj epspv = epspv + ( viscz * kz ** ( 2 * ilap )) * vh * aj / bj endif if ( wkh2n . lt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then zero_kh_grv = zero_kh_grv + vzx + vzy zero_kh_geo = zero_kh_geo + vh * aj / bj endif if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). lt . 1.e-10 ) then zero_kz_geo = zero_kz_geo + vzx + vzy zero_kz_grv = zero_kz_grv + vzz + vh * aj / bj endif if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then eg = eg + real ( ge ( ikx , iky , ikz ) * conjg ( ge ( ikx , iky , ikz ))) / wkh2 ea = ea + real ( g1 ( ikx , iky , ikz ) * conjg ( g1 ( ikx , iky , ikz )) + g2 ( ikx , iky , ikz ) * conjg ( g2 ( ikx , iky , ikz ))) / wkh2 endif endif ! L enddo enddo enddo !! decomposing wave energy to a kinetic and potential part if ( potkinwv_flag == 1 ) then gewv = cmplx ( 0. , 0. ) call atowb ( gewv , g1 , g2 , zxwv , zywv , zzwv , ttwv , ux , uy , uz ) kewv = 0. pewv = 0. do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wk2 = kx * kx + ky * ky + kz * kz if ( L ( ikx , iky , ikz ). eq . 1 ) then kewv = kewv + real ( zxwv ( ikx , iky , ikz ) * conjg ( zxwv ( ikx , iky , ikz ))) / wk2 kewv = kewv + real ( zywv ( ikx , iky , ikz ) * conjg ( zywv ( ikx , iky , ikz ))) / wk2 kewv = kewv + real ( zzwv ( ikx , iky , ikz ) * conjg ( zzwv ( ikx , iky , ikz ))) / wk2 pewv = pewv + real ( ttwv ( ikx , iky , ikz ) * conjg ( ttwv ( ikx , iky , ikz ))) endif enddo enddo enddo endif epsk = 2. * epsk epsp = 2. * epsp epskh = 2. * epskh epsph = 2. * epsph epskv = 2. * epskv epspv = 2. * epspv eg = eg + zero_kz_geo + zero_kh_geo ea = ea + zero_kz_grv + zero_kh_grv if ( aj . ne . 0. . and . bj . ne . 0. ) pe = aj * pe / bj if ( aj . ne . 0. . and . bj . ne . 0. ) pewv = aj * pewv / bj call mpi_reduce ( ke , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); ke = tmp call mpi_reduce ( pe , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); pe = tmp call mpi_reduce ( eg , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); eg = tmp call mpi_reduce ( ea , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); ea = tmp call mpi_reduce ( rms_verv , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); rms_verv = tmp call mpi_reduce ( rms_horv , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); rms_horv = tmp if ( keepEPS == 1 ) then call mpi_reduce ( epsk , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); epsk = tmp call mpi_reduce ( epsp , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); epsp = tmp call mpi_reduce ( epskh , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); epskh = tmp call mpi_reduce ( epsph , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); epsph = tmp call mpi_reduce ( epskv , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); epskv = tmp call mpi_reduce ( epspv , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); epspv = tmp endif if ( potkinwv_flag == 1 ) then deallocate ( gewv ) call mpi_reduce ( kewv , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); kewv = tmp call mpi_reduce ( pewv , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ); pewv = tmp endif if ( mype . eq . 0 ) then ! prep for output if ( cor . gt . 1.e-10 ) then rossby = sqrt ( 2. * rms_verv / cor2 ) else rossby = - 99 9. endif if ( bf . gt . 1.e-8 ) then fr_z = sqrt ( rms_horv ) / bf fr_h = sqrt ( 2. * rms_verv ) / bf else fr_z = - 99 9. fr_h = - 99 9. endif eps = epsk + epsp if ( aj . ne . 0. . and . bj . ne . 0. ) then e = ( pe + ke ) else e = - 99 9. endif if ( nt . eq . 0 ) then if ( potkinwv_flag == 1 ) then write ( iuRESULT , 5043 ) write ( iuRESULT , 5042 ) repeat ( '----------' , 15 ) else write ( iuRESULT , 5049 ) write ( iuRESULT , 5042 ) repeat ( '----------' , 13 ) endif endif scaletime = 360 0.0 if ( potkinwv_flag == 1 ) then write ( iuRESULT , 5044 ) time / scaletime , ke , pe , kewv , pewv , e , eg , ea , rossby , fr_z , fr_h if ( keepENG == 1 ) write ( iuENG , 5045 ) time / scaletime , ke , pe , kewv , pewv , e , eg , ea , rossby , fr_z , fr_h else write ( iuRESULT , 5048 ) time / scaletime , ke , pe , e , eg , ea , rossby , fr_z , fr_h if ( keepENG == 1 ) write ( iuENG , 5046 ) time / scaletime , ke , pe , e , eg , ea , rossby , fr_z , fr_h endif call flush ( iuRESULT ) if ( keepEPS == 1 ) write ( iuEPS , 5046 ) time / scaletime , epsk , epsp , eps , epskh , epskv , epsph , epspv if ( keepENG == 1 ) call flush ( iuENG ) if ( keepEPS == 1 ) call flush ( iuEPS ) endif return 5042 format ( 1 x , a91 ) 5043 format ( 8 x , ' T' , 8 x , 'KE' , 8 x , 'PE' , 8 x , 'KEWV' , 6 x , 'PEWV' , 6 x , 'E' , 9 x , 'GE' , 8 x , 'AE' , 8 x , 'Ro' , 8 x , 'Fr_z' , 7 x , 'Fr_h' ) 5049 format ( 8 x , ' T' , 8 x , 'KE' , 8 x , 'PE' , 8 x , 'E' , 9 x , 'GE' , 8 x , 'AE' , 8 x , 'Ro' , 8 x , 'Fr_z' , 7 x , 'Fr_h' ) 5044 format ( 1 x , f12 . 2 , 2 x , 10 ( f8 . 3 , 2 x )) 5048 format ( 1 x , f12 . 2 , 2 x , 8 ( f8 . 3 , 2 x )) 5045 format ( 1 x , f12 . 2 , 2 x , 10 ( e11 . 4 , 1 x )) 5046 format ( 1 x , f12 . 2 , 2 x , 8 ( e11 . 4 , 1 x )) 5047 format ( 1 x , f12 . 2 , 2 x , 7 ( e21 . 14 , 1 x )) end subroutine out_eng subroutine spec ( zx , zy , zz , tt , ux , uy , uz , ge , g1 , g2 , zxwv , zywv , zzwv , ttwv , ispec , iu ) ! Calculates spectra using: ! ispec = 1: total wavenumber k ! ispec = 2: horizontal wavenumber kh ! ispec = 3: vertical wavenumber kz implicit none include 'mpif.h' integer , intent ( in ) :: ispec , iu complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt , ge , g1 , g2 complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: ux , uy , uz , zxwv , zywv , zzwv , ttwv integer :: ikx , iky , ikz , ikza , j , i , j0 integer :: nspz , nspz13 , nspz15 real :: kx , ky , kz , wk , wkh2 , wkh , wkh2n , kzn , kz2 real :: vt , kvisc , vzx , vzy , vzz complex :: div real , dimension (:,:), allocatable :: spz , spztot integer , dimension ( 0 : kts ) :: n , ntot complex , dimension (:,:,:), allocatable :: gewv if ( potkinwv_flag == 1 ) then allocate ( gewv ( iktx , ikty , iktzp )) allocate ( spz ( 0 : kts , 15 ), spztot ( 0 : kts , 15 )) else allocate ( spz ( 0 : kts , 13 ), spztot ( 0 : kts , 13 )) endif nspz = kts + 1 nspz13 = ( kts + 1 ) * 13 nspz15 = ( kts + 1 ) * 15 if ( ispec . eq . 1 ) then j0 = 1 elseif ( ispec . eq . 2 ) then j0 = 0 elseif ( ispec . eq . 3 ) then j0 = 0 else print * , \"ispec error\" stop endif N = 0 spz = 0. call velo ( zx , zy , zz , ux , uy , uz ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) kz2 = kz * kz kzn = kz * L3 / twopi do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wkh2 = kx * kx + ky * ky wkh2n = wkh2 * ( L1 / twopi ) ** 2 wkh = sqrt ( wkh2 ) wk = sqrt ( kx * kx + ky * ky + kz * kz ) kvisc = visch * wkh2 ** ilap + viscz * kz2 ** ilap if ( ispec . eq . 1 ) then j = int ( wk * L1 / twopi + 0.5 ) elseif ( ispec . eq . 2 ) then j = int ( wkh * L1 / twopi + 0.5 ) elseif ( ispec . eq . 3 ) then j = int ( abs ( kz ) * L3 / twopi + 0.5 ) endif if ( L ( ikx , iky , ikz ). eq . 1 ) then if ( j . lt . j0 . or . j . gt . kts ) print * , 'SPEC: SCREW-UP.' , j , 'ktx= ' , ktx , 'ispec=' , ispec wk = max ( wk , 1.e-15 ) wkh2 = max ( wkh2 , 1.e-15 ) ! Kinetic and potential energy. vzx = real ( zx ( ikx , iky , ikz ) * conjg ( zx ( ikx , iky , ikz )) ) vzy = real ( zy ( ikx , iky , ikz ) * conjg ( zy ( ikx , iky , ikz )) ) vzz = real ( zz ( ikx , iky , ikz ) * conjg ( zz ( ikx , iky , ikz )) ) vt = real ( tt ( ikx , iky , ikz ) * conjg ( tt ( ikx , iky , ikz )) ) spz ( j , 1 ) = spz ( j , 1 ) + vzx / wk ** 2 + vzy / wk ** 2 + vzz / wk ** 2 spz ( j , 2 ) = spz ( j , 2 ) + vt * aj / bj ! KE and PE dissipation spz ( j , 7 ) = spz ( j , 7 ) + kvisc * ( vzx / wk ** 2 + vzy / wk ** 2 + vzz / wk ** 2 ) spz ( j , 8 ) = spz ( j , 8 ) + kvisc * vt * aj / bj ! Geo, ageo decompostition. ! k \\in R_k if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then vzx = real ( ge ( ikx , iky , ikz ) * conjg ( ge ( ikx , iky , ikz )) ) vzy = real ( g1 ( ikx , iky , ikz ) * conjg ( g1 ( ikx , iky , ikz )) ) vzz = real ( g2 ( ikx , iky , ikz ) * conjg ( g2 ( ikx , iky , ikz )) ) spz ( j , 4 ) = spz ( j , 4 ) + vzx / wkh2 spz ( j , 5 ) = spz ( j , 5 ) + vzy / wkh2 + vzz / wkh2 ! spz(j,7) = spz(j,7) + kvisc*vzx/wkh2 ! spz(j,8) = spz(j,8) + kvisc*vzy/wkh2 + kvisc*vzz/wkh2 endif ! Special cases: i) k_h=0, ii) k_z=0. vzx = real ( ux ( ikx , iky , ikz ) * conjg ( ux ( ikx , iky , ikz )) ) vzy = real ( uy ( ikx , iky , ikz ) * conjg ( uy ( ikx , iky , ikz )) ) vzz = real ( uz ( ikx , iky , ikz ) * conjg ( uz ( ikx , iky , ikz )) ) ! k \\in V_k if ( wkh2n . lt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then spz ( j , 4 ) = spz ( j , 4 ) + vzz + vt * aj / bj spz ( j , 5 ) = spz ( j , 5 ) + vzx + vzy ! spz(j,7) = spz(j,7) + kvisc*(vzz + vt*aj/bj) ! spz(j,8) = spz(j,8) + kvisc*(vzx + vzy) endif ! k \\in B_k if ( abs ( kzn ). lt . 1.e-10 . and . wkh2n . gt . 1.e-10 ) then spz ( j , 4 ) = spz ( j , 4 ) + vzx + vzy spz ( j , 5 ) = spz ( j , 5 ) + vzz + vt * aj / bj ! spz(j,7) = spz(j,7) + kvisc*(vzx + vzy) ! spz(j,8) = spz(j,8) + kvisc*(vzz + vt*aj/bj) endif ! Buoyancy Flux if ( aj . gt . 0. ) then vt = aj * real ( conjg ( uz ( ikx , iky , ikz )) * tt ( ikx , iky , ikz )) else vt = real ( conjg ( uz ( ikx , iky , ikz )) * tt ( ikx , iky , ikz )) endif spz ( j , 6 ) = spz ( j , 6 ) + vt ! KE decomposed into u/v/w spz ( j , 9 ) = spz ( j , 9 ) + vzx spz ( j , 10 ) = spz ( j , 10 ) + vzy spz ( j , 11 ) = spz ( j , 11 ) + vzz ! Rotational and divergent KE div = kx * ux ( ikx , iky , ikz ) + ky * uy ( ikx , iky , ikz ) vzx = real ( div * conjg ( div ) ) / wkh2 vzz = real ( zz ( ikx , iky , ikz ) * conjg ( zz ( ikx , iky , ikz )) ) / wkh2 spz ( j , 12 ) = spz ( j , 12 ) + vzz spz ( j , 13 ) = spz ( j , 13 ) + vzx n ( j ) = n ( j ) + 2 endif enddo enddo enddo spz (:, 3 ) = spz (:, 1 ) + spz (:, 2 ) if ( potkinwv_flag == 1 ) then gewv = cmplx ( 0. , 0. ) call atowb ( gewv , g1 , g2 , zxwv , zywv , zzwv , ttwv , ux , uy , uz ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wk = sqrt ( kx * kx + ky * ky + kz * kz ) wkh = sqrt ( kx * kx + ky * ky ) if ( ispec . eq . 1 ) then j = int ( wk * L1 / twopi + 0.5 ) elseif ( ispec . eq . 2 ) then j = int ( wkh * L1 / twopi + 0.5 ) elseif ( ispec . eq . 3 ) then j = int ( abs ( kz ) * L3 / twopi + 0.5 ) endif if ( L ( ikx , iky , ikz ). eq . 1 ) then ! Kinetic and potential energy of the waves vzx = real ( zxwv ( ikx , iky , ikz ) * conjg ( zxwv ( ikx , iky , ikz )) ) vzy = real ( zywv ( ikx , iky , ikz ) * conjg ( zywv ( ikx , iky , ikz )) ) vzz = real ( zzwv ( ikx , iky , ikz ) * conjg ( zzwv ( ikx , iky , ikz )) ) vt = real ( ttwv ( ikx , iky , ikz ) * conjg ( ttwv ( ikx , iky , ikz )) ) spz ( j , 14 ) = spz ( j , 14 ) + vzx / wk ** 2 + vzy / wk ** 2 + vzz / wk ** 2 spz ( j , 15 ) = spz ( j , 15 ) + vt * aj / bj endif enddo enddo enddo endif if ( potkinwv_flag == 1 ) then deallocate ( gewv ) call mpi_reduce ( spz , spztot , nspz15 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) else call mpi_reduce ( spz , spztot , nspz13 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) endif call mpi_reduce ( n , ntot , nspz , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) if ( mype . eq . 0 ) then do j = j0 , kts - 1 if ( ntot ( j ). ne . 0 ) then if ( potkinwv_flag == 1 ) then write ( iu , 5011 ) float ( j ),( spztot ( j , i ), i = 1 , 15 ), ntot ( j ) else write ( iu , 5000 ) float ( j ),( spztot ( j , i ), i = 1 , 13 ), ntot ( j ) endif endif enddo write ( iu , * ) '           ' !    write(iu,*) '           ' call flush ( iu ) endif deallocate ( spz , spztot ) return 5000 format ( 1 X , F4 . 0 , 4 X , 13 ( E13 . 6 , 1 x ), 6 X , I12 ) 5011 format ( 1 X , F4 . 0 , 4 X , 15 ( E13 . 6 , 1 x ), 6 X , I12 ) end subroutine spec subroutine transf ( zx , zy , zz , tt , geok , gw1k , gw2k , nzx , nzy , nzz , ntt , ngeok , ngw1k , ngw2k , nuk , nvk , nwk , ispec , iu ) ! Calculates transfer spectra. ! ispec = 1: k ! ispec = 2: kh ! ispec = 3: kz implicit none include 'mpif.h' integer , intent ( in ) :: ispec , iu complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt , nzx , nzy , nzz , ntt , geok , gw1k , gw2k complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: ngeok , ngw1k , ngw2k , nuk , nvk , nwk integer :: ikx , iky , ikz , ikza , j , j0 , nspz , nspz6 integer , dimension ( 0 : kts ) :: n , ntot real :: kx , ky , kz , k , k2 , kh2 , wkh , kh2n , kzn real :: vzx , vzy , vzz , vtt real , dimension ( 0 : kts , 6 ) :: spz , spztot complex :: u , v , w , c1 , c2 , c3 nspz = kts + 1 nspz6 = ( kts + 1 ) * 6 if ( ispec . eq . 1 ) then j0 = 1 elseif ( ispec . eq . 2 ) then j0 = 0 elseif ( ispec . eq . 3 ) then j0 = 0 else print * , \"ispec error\" stop endif call wtoab ( nzx , nzy , nzz , ntt , ngeok , ngw1k , ngw2k , nuk , nvk , nwk ) call velo ( nzx , nzy , nzz , nuk , nvk , nwk ) N = 0 spz = 0. do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) kzn = kz * L3 / twopi do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) kh2 = kx * kx + ky * ky kh2n = kh2 * ( L1 / twopi ) ** 2 kh2 = max ( 1.e-15 , kh2 ) wkh = sqrt ( kh2 ) k2 = kx * kx + ky * ky + kz * kz k = sqrt ( k2 ) k2 = max ( 1.e-15 , k2 ) if ( ispec . eq . 1 ) then j = int ( k * L1 / twopi + 0.5 ) elseif ( ispec . eq . 2 ) then j = int ( wkh * L1 / twopi + 0.5 ) elseif ( ispec . eq . 3 ) then j = int ( abs ( kz ) * L3 / twopi + 0.5 ) endif if ( L ( ikx , iky , ikz ). eq . 1 ) then if ( j . lt . j0 . or . j . gt . kts ) then print * , 'transf: screw-up.   k= ' , j , kx , ky , kz , L ( ikx , iky , ikz ) endif c1 = ky * zz ( ikx , iky , ikz ) - kz * zy ( ikx , iky , ikz ) c2 = kz * zx ( ikx , iky , ikz ) - kx * zz ( ikx , iky , ikz ) c3 = kx * zy ( ikx , iky , ikz ) - ky * zx ( ikx , iky , ikz ) u = zi * c1 / k2 v = zi * c2 / k2 w = zi * c3 / k2 ! k \\in R_k if ( kh2n . gt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then spz ( j , 1 ) = spz ( j , 1 ) + real ( geok ( ikx , iky , ikz ) * conjg ( ngeok ( ikx , iky , ikz ))) / kh2 spz ( j , 2 ) = spz ( j , 2 ) + real ( gw1k ( ikx , iky , ikz ) * conjg ( ngw1k ( ikx , iky , ikz ))) / kh2 spz ( j , 2 ) = spz ( j , 2 ) + real ( gw2k ( ikx , iky , ikz ) * conjg ( ngw2k ( ikx , iky , ikz ))) / kh2 endif ! Special cases: i) k_h=0, ii) k_z=0. vzx = real ( u * conjg ( nuk ( ikx , iky , ikz ))) vzy = real ( v * conjg ( nvk ( ikx , iky , ikz ))) vzz = real ( w * conjg ( nwk ( ikx , iky , ikz ))) vtt = real ( tt ( ikx , iky , ikz ) * conjg ( ntt ( ikx , iky , ikz ))) !  k \\in V_k if ( kh2n . lt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then spz ( j , 1 ) = spz ( j , 1 ) + vtt spz ( j , 2 ) = spz ( j , 2 ) + vzx + vzy endif !  k \\in B_k if ( kh2n . gt . 1.e-10 . and . abs ( kzn ). lt . 1.e-10 ) then spz ( j , 1 ) = spz ( j , 1 ) + vzx + vzy spz ( j , 2 ) = spz ( j , 2 ) + vzz + vtt * aj / bj endif !  Now, compute KE and PE transfer spz ( j , 4 ) = spz ( j , 4 ) + vzx + vzy + vzz spz ( j , 5 ) = spz ( j , 5 ) + vtt * aj / bj n ( j ) = n ( j ) + 2 endif enddo enddo enddo spz (:, 3 ) = spz (:, 1 ) + spz (:, 2 ) spz (:, 6 ) = spz (:, 4 ) + spz (:, 5 ) call mpi_reduce ( spz , spztot , nspz6 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) call mpi_reduce ( n , ntot , nspz , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) if ( mype . eq . 0 ) then do j = j0 , kts - 1 if ( ntot ( j ). ne . 0 ) then write ( iu , 5000 ) float ( j ),( spztot ( j , iky ), iky = 1 , 6 ), ntot ( j ) endif enddo write ( iu , * ) '     ' ! write(iu,*) '     ' endif return 5000 format ( 1 X , F4 . 0 , 4 X , 6 ( E11 . 4 , 1 x ), 10 X , I6 ) end subroutine transf subroutine do_diagnostics ( zx , zy , zz , tt , geok , gw1k , gw2k , nzxk , nzyk , nzzk , nttk , rhzx , rhzy , rhzz , rhtt , uk , vk , wk , nt ) !! Do all the diagnostics here. Customise based on what you need for analysis implicit none include 'mpif.h' integer , intent ( in ) :: nt complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt , nzxk , nzyk , nzzk , nttk , geok , gw1k , gw2k complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: rhzx , rhzy , rhzz , rhtt , uk , vk , wk !! Note in the following subroutines (spec,trans,out_eng) zx,zy,zz,tt,nzx,nzy,nzz,ntt,geok,gw1k,gw2k !! remain unchanged but call out_eng ( zx , zy , zz , tt , uk , vk , wk , geok , gw1k , gw2k , rhzx , rhzy , rhzz , rhtt , nt ) if ( keepSPCH == 1 ) call spec ( zx , zy , zz , tt , uk , vk , wk , geok , gw1k , gw2k , rhzx , rhzy , rhzz , rhtt , 2 , iuSPCH ) if ( keepSPCZ == 1 ) call spec ( zx , zy , zz , tt , uk , vk , wk , geok , gw1k , gw2k , rhzx , rhzy , rhzz , rhtt , 3 , iuSPCZ ) if ( keepSPC == 1 ) call spec ( zx , zy , zz , tt , uk , vk , wk , geok , gw1k , gw2k , rhzx , rhzy , rhzz , rhtt , 1 , iuSPC ) if ( keepTRNH == 1 ) call transf ( zx , zy , zz , tt , geok , gw1k , gw2k , nzxk , nzyk , nzzk , nttk , rhzx , rhzy , rhzz , uk , vk , wk , 2 , iuTRNH ) if ( keepTRNZ == 1 ) call transf ( zx , zy , zz , tt , geok , gw1k , gw2k , nzxk , nzyk , nzzk , nttk , rhzx , rhzy , rhzz , uk , vk , wk , 3 , iuTRNZ ) if ( keepTRN == 1 ) call transf ( zx , zy , zz , tt , geok , gw1k , gw2k , nzxk , nzyk , nzzk , nttk , rhzx , rhzy , rhzz , uk , vk , wk , 1 , iuTRN ) return end subroutine do_diagnostics end module diagnostics","tags":"","loc":"sourcefile/diagnostics.f90.html"},{"title":"param.F90 – Boussinesq DNS","text":"Source Code module param use , intrinsic :: iso_c_binding implicit none ! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ! @@@@@@@@@@@@@@@ PARAMETERS AND GLOBAL VARIABLES @@@@@@@@@@@@@@@@@ ! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ! ================================================================= ! ================ SIMULATION RELATED PARAMETERS ================== ! ================================================================= ! ----------------------------------------------------------------- ! Set Model Resolution integer ( C_INTPTR_T ), parameter :: n1 = 1024 , n2 = 1024 , n3 = 256 ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Set Number of Processors (must divide n2 and iktz) integer , save :: npe = 256 ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Math constants real , parameter :: twopi = 4. * asin ( 1. ) real , parameter :: sqrt2 = sqrt ( 2. ) complex , parameter :: zi = cmplx ( 0. , 1. ) ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Time real , save :: time ! global variable showing time real , parameter :: delt = 5 ! timestep real , parameter :: tstop = 2 * 24 * 3600 ! length of integration integer , parameter :: nstop = int ( tstop / delt ) ! number of timesteps ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Stratification and Rotation real , parameter :: PrRa = 100 ! Prandtle Ratio  N/f real , parameter :: aj = 1e-2 ! thermal expansivity, N&#94;2 = aj*bj real , parameter :: bj = aj ! background theta gradient real , parameter :: bf2 = aj * bj ! Brunt-Vaisalla freq squared real , parameter :: bf = sqrt ( bf2 ) ! Brunt-Vaisalla frequency real , parameter :: cor = 1.1e-4 ! Coriolis parameter real , parameter :: cor2 = cor * cor ! Coriolis parameter squared ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Set Domain Size real , parameter :: L1 = 8e6 , L2 = 8e6 real , parameter :: L3 = 2e4 ! makes dx=dz ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Physical and Fourier Array Dimensions integer ( C_INTPTR_T ), parameter :: n1d = n1 + 2 , n2d = n2 , n3d = n3 ! size of physical arrays (padded for in-place transforms) integer ( C_INTPTR_T ), save :: n2dp , n2p ! size of local arrays with mpi, n2dp=n2d/npe, n2p=n2/npe integer ( C_INTPTR_T ), parameter :: ktx = n1 / 2 , kty = n2 / 2 , ktz = n3 / 2 ! max integer wavenumber integer ( C_INTPTR_T ), parameter :: iktx = ktx + 1 , ikty = n2 , iktz = n3 ! no. of wavenumbers integer ( C_INTPTR_T ), save :: iktzp ! no. of local wavenumbers(mpi), iktzp=iktz/npe integer ( C_INTPTR_T ), parameter :: kts = n1 ! for spectra; should be max(ktx,ktz) real , parameter :: ktrunc_x = twopi / L1 * float ( n1 ) / 3. ! dimensional trunc wavenumber (x) not index real , parameter :: ktrunc_y = twopi / L2 * float ( n2 ) / 3. ! dimensional trunc wavenumber (y) real , parameter :: ktrunc_z = twopi / L3 * float ( n3 ) / 3. ! dimensional trunc wavenumber (z) ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Dissipation integer , parameter :: ilap = 4 , ilap2 = 2 * ilap ! hyperviscosity order (ilap=1 regular visc) ! ----------------------------------------------------------------- real , parameter :: vischtmp = 5.e-5 * ( 1 0. / ktrunc_x ) ** 2. real , parameter :: viscztmp = 5.e-5 * ( 1 0. / ktrunc_z ) ** 2. real , parameter :: visch = 3.0e26 !vischtmp * ktrunc_x **(2-2*ilap) ! viscosity coeff horizontal real , parameter :: viscz = 1e3 !!viscztmp * ktrunc_z **(2-2*ilap) ! viscosity coeff vertical ! ----------------------------------------------------------------- ! Linear Damping real , parameter :: ek = 1. / ( 2 4. * 360 0. ) * delt ! kh=0 damping time scale real , parameter :: kdamping = 3. ! damping on k <= kdamping ! ----------------------------------------------------------------- ! Forcing integer , parameter :: forcing_flag = 1 ! = 1 force (see forcing.F90) ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Wavenumbers integer , dimension (:,:,:), allocatable , save :: L ! Mask for wavenumber truncation real , dimension (:), allocatable , save :: kxa , kya , kza ! Wavenumbers ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! MPI Stuff integer , save :: mype integer ( C_INTPTR_T ), save :: locz , loczstart ! size and position of block in z integer ( C_INTPTR_T ), save :: alloc_local ! local data size for malloc integer , save :: istatus ! used for mpi initiation ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Initial Condition Parameters ! icmode = 0 ---> generate IC only based on a descriptions (see init_condition.F90) ! icmode = 1 ---> read IC from a netCDF file ! icmode = 2 ---> a superpostion of the netCDF file and describing functions integer , parameter :: icmode = 1 ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! Misc Stuff integer , parameter :: iuRESULT = 11 ! ID for outputting the results (run.list) integer , parameter :: truncmode = 0 ! 1 spherical truncation; 0 cylindrical real , parameter :: fftnorm = float ( n1 * n2 * n3 ) ! used to normal fft/fftinverse ! ----------------------------------------------------------------- ! ================================================================= ! =============== DIAGNOSTICS RELATED PARAMETERS ================== ! ================================================================= ! >> the most frequently-changed parameters of modules are below ! >> the other parameters should be changed inside each modules ! ±±±±±±±±±±±±±±±±±±±± Input and Output Files ±±±±±±±±±±±±±±±±±±±±± ! ----------------------------------------------------------------- integer , parameter :: ncwrite = 1 ! flag for dumping field for other sim's restart ! Note: just the last point in time is dumped ! ±±±±±±±±±±±±±±±±±±±±±±± diagnostics.F90 ±±±±±±±±±±±±±±±±±±±±±±±±± ! >>>  output files: spc?.dat, eng.dat, trn?.dat, run.list and etc ! ----------------------------------------------------------------- ! frequency of outputing diagnostics integer , parameter :: ndiagout = 24 ! number of times data dumped integer , parameter :: ndiagevery = floor ( nstop / float ( ndiagout )) ! do diag. every ndiagevery timesteps ! ----------------------------------------------------------------- ! ----------------------------------------------------------------- ! ±±±±±±±±±±±±±±±± slices of real(physical) space ±±±±±±±±±±±±±±±±± ! >>>  parameters in realspacedumps.F90 ! ----------------------------------------------------------------- integer , parameter :: realspace_flag = 0 ! = 0 nothing dumped & realspacedumps.F90 not used integer , parameter :: nrsout = 1 ! number of time slices dumped integer , parameter :: nrsevery = floor ( nstop / float ( nrsout )) ! dump slices every nrsevery timesteps ! starting and end points in slices integer , parameter :: nHstart = 1 , nHend = n1 integer , parameter :: nVstart = 1 , nVend = n3 ! number points to skip integer , parameter :: nskipH = 1 ! skip (horizontal) physical points every nskipH (nskip=1 keep all) integer , parameter :: nskipV = 1 ! vertical ! ----------------------------------------------------------------- end module param","tags":"","loc":"sourcefile/param.f90.html"},{"title":"boussinesq.F90 – Boussinesq DNS","text":"Source Code ! Triply Periodic Boussinesq ! Original Code by Peter Bartello ! Rewritten by Michael Waite ! f90, mpi: Winter 2008-2009 ! Cleaned up Winter 2012 ! Summer 2012: Upgraded netcdf calls to nf90; upgraded to module param ! Modified by Karthik Velakur, 2013-2014: updated to FFTW3, output slices ! To compile: have to link to FFTW and NETCDF libraries ! Further modified and customised by Hossein Kafiabad !     NOTES: !     kx,ky,kz are wavenumbers. !     ikx,y,z  are corresponding array indices. !     KTX,Y,Z  are truncation wavenumbers. !     IKTX,Y,Z are corresponding indices. !     Code solves Boussinesq equations in vorticity form. !     zx,y,z is vorticity. u,v,w is velocity.  t is potential temp. !     nzx,y,z is nonlinear term in vorticity equation. !     zxnk,zynk,zznk,ttnk are fields at current time level (n) !     zxok,zyok,zzok,ttok are fields at time level n-1. ** !     zx1k,zy1k,zz1k,tt1k are fields at time level n-2. ** (AB3 only) !     ** NOTE: for AB3, store right-hand-side, not basic fields, at times n-1 and n-2. !     FFTW v 3.3.3 Manual can be found at http://www.fftw.org PROGRAM MAIN use param use velvorproj use param_fftw use nm_decomp use diagnostics use IO_netcdf use init_condition use forcing use realspacedumps2 use misc implicit none ! ----------------------------------------------------------------- ! Additional Parameters ! ----------------------------------------------------------------- ! MISC parameters that are not defined in param.F90 real , parameter :: d2 = 2 * delt , d12 = delt / 12 real , parameter :: k2h = visch * delt , k2z = viscz * delt real , parameter :: v2h = visch * delt , v2z = viscz * delt ! ----------------------------------------------------------------- ! Declaration of variables ! ----------------------------------------------------------------- complex , dimension (:,:,:), pointer :: zxok , zyok , zzok , ttok , zxnk , zynk , zznk , ttnk real , dimension (:,:,:), pointer :: zxor , zyor , zzor , ttor , zxnr , zynr , zznr , ttnr type ( C_PTR ) :: zxo_p , zyo_p , zzo_p , tto_p , zxn_p , zyn_p , zzn_p , ttn_p complex , dimension (:,:,:), pointer :: nzxk , nzyk , nzzk , nttk , uk , vk , wk real , dimension (:,:,:), pointer :: nzxr , nzyr , nzzr , nttr , ur , vr , wr type ( C_PTR ) :: nzx_p , nzy_p , nzz_p , ntt_p , u_p , v_p , w_p complex , dimension (:,:,:), allocatable :: rhzx , rhzy , rhzz , rhtt , geok , gw1k , gw2k complex , dimension (:,:,:), allocatable :: zx1k , zy1k , zz1k , tt1k real , dimension (:,:), allocatable :: utseries , vtseries , zztseries real , dimension (:), allocatable :: timetseries integer , dimension (:), allocatable :: mypoints integer :: nomypts complex :: termzx , termzy , termzz , termtt , tzx , tzy , tzz , ttt complex :: u , v , w , c1 , c2 , c3 , gtau ( 1200 , 4 ) real :: dmz , dpz , r1 , r2 , kx , ky , kz , kh , khn , wk2 , k real :: ts integer :: ikx , iky , ikz , ikza , ic , isample integer :: iseed , nt = 0 , nt0 , ntdump integer :: npe1 , inrlcount external :: init_params , convol , constr ! ----------------------------------------------------------------- ! Initialize MPI ! ----------------------------------------------------------------- call mpi_init ( istatus ) call mpi_comm_size ( mpi_comm_world , npe1 , istatus ) call mpi_comm_rank ( mpi_comm_world , mype , istatus ) call fftwf_mpi_init () ! checks on the number of processors if ( mype . eq . 0 ) then print * , 'npe = ' , npe if ( npe . ne . npe1 ) then print * , 'number of requested processers and npe do not mathc!!!' stop endif endif if ( mod ( n2 , npe ). ne . 0 . or . mod ( iktz , npe ). ne . 0 ) then print * , 'npe must divide n2 and iktz' stop endif ! array sizes based on npe iktzp = iktz / npe n2dp = n2d / npe ; n2p = n2 / npe ; ! ----------------------------------------------------------------- ! Allocate arrays not used in FFTW ! ----------------------------------------------------------------- allocate ( L ( iktx , ikty , iktzp )) allocate ( kxa ( iktx )) allocate ( kya ( ikty )) allocate ( kza ( iktz )) allocate ( rhzx ( iktx , ikty , iktzp )) allocate ( rhzy ( iktx , ikty , iktzp )) allocate ( rhzz ( iktx , ikty , iktzp )) allocate ( rhtt ( iktx , ikty , iktzp )) allocate ( geok ( iktx , ikty , iktzp )) allocate ( gw1k ( iktx , ikty , iktzp )) allocate ( gw2k ( iktx , ikty , iktzp )) allocate ( zx1k ( iktx , ikty , iktzp )) allocate ( zy1k ( iktx , ikty , iktzp )) allocate ( zz1k ( iktx , ikty , iktzp )) allocate ( tt1k ( iktx , ikty , iktzp )) ! ----------------------------------------------------------------- ! Allocate arrays used in FFTW ! ----------------------------------------------------------------- ! Get local data size (note dimension reversal), and allocate. ! Use in-place transforms. ! In Fortran order we see real space to Fourier space dimensions in order (kx,ky,kz) <-> (x,z,y) ! For MPI, in C order we have to pass dimensions in reverse order (kz,ky,kx) <-> (y,z,x). ! locz is local block size of z, and loczstart is local starting value of z. ! In our case, since npe|n3, we will have locz=iktzp over all processors. ! Also rows are always divided in kz by rank order. So proc of rank 0 will have first ! block, proc 1 will have second, and so on. ! cf. Sec 6.4, 6.5, 6.13 and 7.2 of FFTW manual alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) zxo_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( zxo_p , zxok , [ iktx , ikty , iktzp ]) call c_f_pointer ( zxo_p , zxor , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) zyo_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( zyo_p , zyok , [ iktx , ikty , iktzp ]) call c_f_pointer ( zyo_p , zyor , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) zzo_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( zzo_p , zzok , [ iktx , ikty , iktzp ]) call c_f_pointer ( zzo_p , zzor , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) tto_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( tto_p , ttok , [ iktx , ikty , iktzp ]) call c_f_pointer ( tto_p , ttor , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) zxn_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( zxn_p , zxnk , [ iktx , ikty , iktzp ]) call c_f_pointer ( zxn_p , zxnr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) zyn_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( zyn_p , zynk , [ iktx , ikty , iktzp ]) call c_f_pointer ( zyn_p , zynr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) zzn_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( zzn_p , zznk , [ iktx , ikty , iktzp ]) call c_f_pointer ( zzn_p , zznr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) ttn_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( ttn_p , ttnk , [ iktx , ikty , iktzp ]) call c_f_pointer ( ttn_p , ttnr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) nzx_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( nzx_p , nzxk , [ iktx , ikty , iktzp ]) call c_f_pointer ( nzx_p , nzxr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) nzy_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( nzy_p , nzyk , [ iktx , ikty , iktzp ]) call c_f_pointer ( nzy_p , nzyr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) nzz_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( nzz_p , nzzk , [ iktx , ikty , iktzp ]) call c_f_pointer ( nzz_p , nzzr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) ntt_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( ntt_p , nttk , [ iktx , ikty , iktzp ]) call c_f_pointer ( ntt_p , nttr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) u_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( u_p , uk , [ iktx , ikty , iktzp ]) call c_f_pointer ( u_p , ur , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) v_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( v_p , vk , [ iktx , ikty , iktzp ]) call c_f_pointer ( v_p , vr , [ n1d , n3d , n2p ]) alloc_local = fftwf_mpi_local_size_many ( 3 ,( / iktz , ikty , iktx / ), 1_8 , iktzp , mpi_comm_world , locz , loczstart ) w_p = fftwf_alloc_complex ( alloc_local ) call c_f_pointer ( w_p , wk , [ iktx , ikty , iktzp ]) call c_f_pointer ( w_p , wr , [ n1d , n3d , n2p ]) ! ----------------------------------------------------------------- ! INITIALIZE FFTW. Dimesension are passed in reverse to MPI C routines. ! ----------------------------------------------------------------- ! FFTW_MPI_TRANSPOSED_OUT flag to compute forward  DFT: (y,z,x) -> (kz,ky,kx). Fortran sees this as (kx,ky,kz). ! FFTW_MPI_TRANSPOSED_IN  flag to compute backward DFT: (kz,ky,kx), viewed as (ky,kz,kx) -> (y,z,x). Fortran sees this as (x,z,y). if ( mype . eq . 0 ) print * , 'Initializing FFTW' plan3_ur_uk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , ur , uk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_vr_vk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , vr , vk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_wr_wk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , wr , wk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_zxnr_zxnk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , zxnr , zxnk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_zynr_zynk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , zynr , zynk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_zznr_zznk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , zznr , zznk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_ttnr_ttnk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , ttnr , ttnk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_nzxr_nzxk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , nzxr , nzxk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_nzyr_nzyk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , nzyr , nzyk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_nzzr_nzzk = fftwf_mpi_plan_dft_r2c_3d ( n2 , n3 , n1 , nzzr , nzzk , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_OUT )) plan3_uk_ur = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , uk , ur , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) plan3_vk_vr = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , vk , vr , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) plan3_wk_wr = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , wk , wr , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) plan3_zxnk_zxnr = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , zxnk , zxnr , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) plan3_zynk_zynr = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , zynk , zynr , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) plan3_zznk_zznr = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , zznk , zznr , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) plan3_ttnk_ttnr = fftwf_mpi_plan_dft_c2r_3d ( n2 , n3 , n1 , ttnk , ttnr , mpi_comm_world , IOR ( FFTW_MEASURE , FFTW_MPI_TRANSPOSED_IN )) ! ----------------------------------------------------------------- ! Initialize parameters, fields, L, etc. ! ----------------------------------------------------------------- ! Open run.list file if ( mype . eq . 0 ) then open ( iuRESULT , file = 'run.list' , form = 'formatted' ) endif ! initialising parameters (kxa, kya and kza) and L(:,:,:) call init_params () ! defining initial condition (look at module init_condition.F90) call init_cond ( zxok , zyok , zzok , ttok , uk , vk , wk , geok , gw1k , gw2k , zxor , zyor , zzor , ttor , ur , vr , wr , ts ) ! initialize a few last things time = ts + nt * delt gtau = cmplx ( 0. , 0. ) zx1k = cmplx ( 0. , 0. ) zy1k = cmplx ( 0. , 0. ) zz1k = cmplx ( 0. , 0. ) tt1k = cmplx ( 0. , 0. ) ! ----------------------------------------------------------------- ! Preps for diagnostics, physical space slices and time series ! ----------------------------------------------------------------- call prep_diagnostics () if ( realspace_flag . ne . 0 ) call prep_realslice () !!$  if (npts.gt.0) then !!$     allocate(mypoints(npts)) !!$     if (tskept<=0) print*, 'you forgot to specify the variables to keep in time series' !!$     mypoints = 0 !!$     isample = 0 !!$     do ic = 1,npts !!$        if ( ( (mype*n2dp+1) <= yind(ic) ).and.( yind(ic) <= ((mype+1)*n2dp) ) ) then !!$           mypoints(ic) = 1 !!$        endif !!$     end do !!$     nomypts=sum(mypoints) !!$     if (mype.eq.0) allocate(timetseries(nsamples)) !!$     if ( (kpU.eq.1).and.(nomypts.gt.0) ) allocate(utseries(nomypts,nsamples)) !!$     if ( (kpV.eq.1).and.(nomypts.gt.0) ) allocate(vtseries(nomypts,nsamples)) !!$     if ( (kpZZ.eq.1).and.(nomypts.gt.0) ) allocate(zztseries(nomypts,nsamples)) !!$  end if ! ----------------------------------------------------------------- ! Print out all Parameters ! ----------------------------------------------------------------- call printparameters () ! ----------------------------------------------------------------- ! Diagnostics on Initial Conditions ! ----------------------------------------------------------------- call wtoab ( zxok , zyok , zzok , ttok , geok , gw1k , gw2k , uk , vk , wk ) zxnk = zxok zynk = zyok zznk = zzok ttnk = ttok call convol ( zxnk , zynk , zznk , ttnk , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , & rhzx , rhzy , rhzz , rhtt , zxnr , zynr , zznr , ttnr , nzxr , nzyr , nzzr , nttr ) call do_diagnostics ( zxnk , zynk , zznk , ttnk , geok , gw1k , gw2k , nzxk , nzyk , nzzk , nttk , rhzx , rhzy , rhzz , rhtt , uk , vk , wk , nt ) if ( realspace_flag . ne . 0 ) then call dump_realspace ( zxnk , zynk , zznk , ttnk , uk , vk , wk , zxnr , zynr , zznr , ttnr , ur , vr , wr ) endif ! ----------------------------------------------------------------- ! Beginning of the first timestep.  Use explicit trapezoidal. ! ----------------------------------------------------------------- nt = 1 time = ts + nt * delt call constr ( zxok , zyok , zzok , ttok , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , zxor , zyor , zzor , ttor , nzxr , nzyr , nzzr , nttr ) if ( forcing_flag . ne . 0. ) then call force ( nzxk , nzyk , nzzk , nttk , gtau , nt ) endif do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx if ( L ( ikx , iky , ikz ). ne . 1 ) then zxnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zynk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zznk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) ttnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) else kx = kxa ( ikx ) kh = sqrt ( kx * kx + ky * ky ) khn = kh * L1 / twopi wk2 = kx * kx + ky * ky + kz * kz k = sqrt ( wk2 ) c1 = + ky * zzok ( ikx , iky , ikz ) - kz * zyok ( ikx , iky , ikz ) c2 = + kz * zxok ( ikx , iky , ikz ) - kx * zzok ( ikx , iky , ikz ) c3 = + kx * zyok ( ikx , iky , ikz ) - ky * zxok ( ikx , iky , ikz ) u = zi * c1 / wk2 v = zi * c2 / wk2 w = zi * c3 / wk2 if ( truncmode == 1 ) then ! spherical dissipation r1 = v2h / delt * wk2 ** ilap r2 = k2h / delt * wk2 ** ilap else ! cylindrical dissipation r1 = v2h / delt * kh ** ilap2 + v2z / delt * kz ** ilap2 r2 = k2h / delt * kh ** ilap2 + k2z / delt * kz ** ilap2 endif if ( khn . le . kdamping ) then r1 = r1 + ek / delt r2 = r2 + ek / delt endif termzx = nzxk ( ikx , iky , ikz ) + aj * zi * ky * ttok ( ikx , iky , ikz ) + cor * zi * kz * u - zxok ( ikx , iky , ikz ) * r1 termzy = nzyk ( ikx , iky , ikz ) - aj * zi * kx * ttok ( ikx , iky , ikz ) + cor * zi * kz * v - zyok ( ikx , iky , ikz ) * r1 termzz = nzzk ( ikx , iky , ikz ) + cor * zi * kz * w - zzok ( ikx , iky , ikz ) * r1 termtt = nttk ( ikx , iky , ikz ) - bj * w - ttok ( ikx , iky , ikz ) * r2 rhzx ( ikx , iky , ikz ) = termzx zxnk ( ikx , iky , ikz ) = zxok ( ikx , iky , ikz ) + delt * termzx rhzy ( ikx , iky , ikz ) = termzy zynk ( ikx , iky , ikz ) = zyok ( ikx , iky , ikz ) + delt * termzy rhzz ( ikx , iky , ikz ) = termzz zznk ( ikx , iky , ikz ) = zzok ( ikx , iky , ikz ) + delt * termzz rhtt ( ikx , iky , ikz ) = termtt ttnk ( ikx , iky , ikz ) = ttok ( ikx , iky , ikz ) + delt * termtt endif ! L enddo enddo enddo call constr ( zxnk , zynk , zznk , ttnk , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , zxnr , zynr , zznr , ttnr , nzxr , nzyr , nzzr , nttr ) if ( forcing_flag . ne . 0. ) then call force ( nzxk , nzyk , nzzk , nttk , gtau , nt ) endif do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx if ( L ( ikx , iky , ikz ). ne . 1 ) then zxnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zynk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zznk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) ttnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) else kx = kxa ( ikx ) kh = sqrt ( kx * kx + ky * ky ) khn = kh * L1 / twopi wk2 = kx * kx + ky * ky + kz * kz k = sqrt ( wk2 ) c1 = + ky * zznk ( ikx , iky , ikz ) - kz * zynk ( ikx , iky , ikz ) c2 = + kz * zxnk ( ikx , iky , ikz ) - kx * zznk ( ikx , iky , ikz ) c3 = + kx * zynk ( ikx , iky , ikz ) - ky * zxnk ( ikx , iky , ikz ) u = zi * c1 / wk2 v = zi * c2 / wk2 w = zi * c3 / wk2 if ( truncmode == 1 ) then ! spherical dissipation r1 = v2h / delt * wk2 ** ilap r2 = k2h / delt * wk2 ** ilap else ! cylindrical dissipation r1 = v2h / delt * kh ** ilap2 + v2z / delt * kz ** ilap2 r2 = k2h / delt * kh ** ilap2 + k2z / delt * kz ** ilap2 endif if ( khn . le . kdamping ) then r1 = r1 + ek / delt r2 = r2 + ek / delt endif termzx = nzxk ( ikx , iky , ikz ) + aj * zi * ky * ttnk ( ikx , iky , ikz ) + cor * zi * kz * u - zxnk ( ikx , iky , ikz ) * r1 termzy = nzyk ( ikx , iky , ikz ) - aj * zi * kx * ttnk ( ikx , iky , ikz ) + cor * zi * kz * v - zynk ( ikx , iky , ikz ) * r1 termzz = nzzk ( ikx , iky , ikz ) + cor * zi * kz * w - zznk ( ikx , iky , ikz ) * r1 termtt = nttk ( ikx , iky , ikz ) - bj * w - ttnk ( ikx , iky , ikz ) * r2 zx1k ( ikx , iky , ikz ) = rhzx ( ikx , iky , ikz ) + zxok ( IKX , IKY , IKZ ) * r1 zy1k ( ikx , iky , ikz ) = rhzy ( ikx , iky , ikz ) + zyok ( IKX , IKY , IKZ ) * r1 zz1k ( ikx , iky , ikz ) = rhzz ( ikx , iky , ikz ) + zzok ( IKX , IKY , IKZ ) * r1 tt1k ( ikx , iky , ikz ) = rhtt ( ikx , iky , ikz ) + ttok ( IKX , IKY , IKZ ) * r2 zxok ( ikx , iky , ikz ) = zxok ( ikx , iky , ikz ) + delt * ( termzx + rhzx ( ikx , iky , ikz )) / 2. zyok ( ikx , iky , ikz ) = zyok ( ikx , iky , ikz ) + delt * ( termzy + rhzy ( ikx , iky , ikz )) / 2. zzok ( ikx , iky , ikz ) = zzok ( ikx , iky , ikz ) + delt * ( termzz + rhzz ( ikx , iky , ikz )) / 2. ttok ( ikx , iky , ikz ) = ttok ( ikx , iky , ikz ) + delt * ( termtt + rhtt ( ikx , iky , ikz )) / 2. endif ! L enddo enddo enddo ! ----------------------------------------------------------------- ! Beginning of the second timestep (only necessary for AB3). ! ----------------------------------------------------------------- nt = 2 time = ts + nt * delt call constr ( zxok , zyok , zzok , ttok , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , zxor , zyor , zzor , ttor , nzxr , nzyr , nzzr , nttr ) if ( forcing_flag . ne . 0. ) then call force ( nzxk , nzyk , nzzk , nttk , gtau , nt ) endif do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx if ( L ( ikx , iky , ikz ). ne . 1 ) then zxnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zynk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zznk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) ttnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) else kx = kxa ( ikx ) kh = sqrt ( kx * kx + ky * ky ) khn = kh * L1 / twopi wk2 = kx * kx + ky * ky + kz * kz k = sqrt ( wk2 ) c1 = + ky * zzok ( ikx , iky , ikz ) - kz * zyok ( ikx , iky , ikz ) c2 = + kz * zxok ( ikx , iky , ikz ) - kx * zzok ( ikx , iky , ikz ) c3 = + kx * zyok ( ikx , iky , ikz ) - ky * zxok ( ikx , iky , ikz ) u = ZI * c1 / wk2 v = ZI * c2 / wk2 w = ZI * c3 / wk2 if ( truncmode == 1 ) then ! spherical dissipation r1 = V2H / delt * wk2 ** ILAP r2 = K2H / delt * wk2 ** ILAP else ! cylindrical dissipation r1 = V2H / delt * kh ** ILAP2 + V2Z / delt * kz ** ILAP2 r2 = K2H / delt * kh ** ILAP2 + K2Z / delt * kz ** ILAP2 endif if ( khn . le . kdamping ) then r1 = r1 + ek / delt r2 = r2 + ek / delt endif termzx = nzxk ( ikx , iky , ikz ) + aj * ZI * ky * ttok ( ikx , iky , ikz ) + cor * ZI * kz * u - zxok ( IKX , IKY , IKZ ) * r1 termzy = nzyk ( ikx , iky , ikz ) - aj * ZI * kx * ttok ( ikx , iky , ikz ) + cor * ZI * kz * v - zyok ( IKX , IKY , IKZ ) * r1 termzz = nzzk ( ikx , iky , ikz ) + cor * ZI * kz * w - zzok ( ikx , iky , ikz ) * r1 termtt = nttk ( ikx , iky , ikz ) - bj * w - ttok ( ikx , iky , ikz ) * r2 rhzx ( ikx , iky , ikz ) = termzx zxnk ( ikx , iky , ikz ) = zxok ( ikx , iky , ikz ) + delt * termzx rhzy ( ikx , iky , ikz ) = termzy zynk ( ikx , iky , ikz ) = zyok ( ikx , iky , ikz ) + delt * termzy rhzz ( ikx , iky , ikz ) = termzz zznk ( ikx , iky , ikz ) = zzok ( ikx , iky , ikz ) + delt * termzz rhtt ( ikx , iky , ikz ) = termtt ttnk ( ikx , iky , ikz ) = ttok ( ikx , iky , ikz ) + delt * termtt endif ! L enddo enddo enddo call constr ( zxnk , zynk , zznk , ttnk , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , zxnr , zynr , zznr , ttnr , nzxr , nzyr , nzzr , nttr ) if ( forcing_flag . ne . 0. ) then call force ( nzxk , nzyk , nzzk , nttk , gtau , nt ) endif do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx if ( L ( ikx , iky , ikz ). ne . 1 ) then zxnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zynk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) zznk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) ttnk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) else kx = kxa ( ikx ) kh = sqrt ( kx * kx + ky * ky ) khn = kh * L1 / twopi wk2 = kx * kx + ky * ky + kz * kz k = sqrt ( wk2 ) c1 = + ky * zznk ( ikx , iky , ikz ) - kz * zynk ( ikx , iky , ikz ) c2 = + kz * zxnk ( ikx , iky , ikz ) - kx * zznk ( ikx , iky , ikz ) c3 = + kx * zynk ( ikx , iky , ikz ) - ky * zxnk ( ikx , iky , ikz ) u = zi * c1 / wk2 v = zi * c2 / wk2 w = zi * c3 / wk2 if ( truncmode == 1 ) then ! spherical dissipation r1 = v2h / delt * wk2 ** ilap r2 = k2h / delt * wk2 ** ilap else ! cylindrical dissipation r1 = v2h / delt * kh ** ilap2 + v2z / delt * kz ** ilap2 r2 = k2h / delt * kh ** ilap2 + k2z / delt * kz ** ilap2 endif if ( khn . le . kdamping ) then r1 = r1 + ek / delt r2 = r2 + ek / delt endif termzx = nzxk ( ikx , iky , ikz ) + aj * zi * ky * ttnk ( ikx , iky , ikz ) + cor * zi * kz * u - zxnk ( ikx , iky , ikz ) * r1 termzy = nzyk ( ikx , iky , ikz ) - aj * zi * kx * ttnk ( ikx , iky , ikz ) + cor * zi * kz * v - zynk ( ikx , iky , ikz ) * r1 termzz = nzzk ( ikx , iky , ikz ) + cor * zi * kz * w - zznk ( ikx , iky , ikz ) * r1 termtt = nttk ( ikx , iky , ikz ) - bj * w - ttnk ( ikx , iky , ikz ) * r2 zxnk ( ikx , iky , ikz ) = zxok ( ikx , iky , ikz ) + delt * ( termzx + rhzx ( ikx , iky , ikz )) / 2. zynk ( ikx , iky , ikz ) = zyok ( ikx , iky , ikz ) + delt * ( termzy + rhzy ( ikx , iky , ikz )) / 2. zznk ( ikx , iky , ikz ) = zzok ( ikx , iky , ikz ) + delt * ( termzz + rhzz ( ikx , iky , ikz )) / 2. ttnk ( ikx , iky , ikz ) = ttok ( ikx , iky , ikz ) + delt * ( termtt + rhtt ( ikx , iky , ikz )) / 2. zxok ( ikx , iky , ikz ) = rhzx ( ikx , iky , ikz ) + zxok ( IKX , IKY , IKZ ) * r1 zyok ( ikx , iky , ikz ) = rhzy ( ikx , iky , ikz ) + zyok ( IKX , IKY , IKZ ) * r1 zzok ( ikx , iky , ikz ) = rhzz ( ikx , iky , ikz ) + zzok ( IKX , IKY , IKZ ) * r1 ttok ( ikx , iky , ikz ) = rhtt ( ikx , iky , ikz ) + ttok ( IKX , IKY , IKZ ) * r2 endif ! L enddo enddo enddo ! ----------------------------------------------------------------- !                        Subsequent Timesteps ! ----------------------------------------------------------------- nt0 = 3 ! AB3: start at nt=3 do nt = nt0 , NSTOP time = ts + nt * delt call convol ( zxnk , zynk , zznk , ttnk , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , & rhzx , rhzy , rhzz , rhtt , zxnr , zynr , zznr , ttnr , nzxr , nzyr , nzzr , nttr ) if ( forcing_flag . ne . 0. ) then call force ( nzxk , nzyk , nzzk , nttk , gtau , nt ) endif call velo ( zxnk , zynk , zznk , rhzx , rhzy , rhzz ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) kh = sqrt ( kx * kx + ky * ky ) khn = kh * L1 / twopi wk2 = kx * kx + ky * ky + kz * kz k = sqrt ( wk2 ) ! Equations: termzx = nzxk ( ikx , iky , ikz ) + aj * ZI * ky * ttnk ( ikx , iky , ikz ) + cor * ZI * kz * rhzx ( ikx , iky , ikz ) termzy = nzyk ( ikx , iky , ikz ) - aj * ZI * kx * ttnk ( ikx , iky , ikz ) + cor * ZI * kz * rhzy ( ikx , iky , ikz ) termzz = nzzk ( ikx , iky , ikz ) + cor * ZI * kz * rhzz ( ikx , iky , ikz ) termtt = nttk ( ikx , iky , ikz ) - bj * rhzz ( ikx , iky , ikz ) if ( truncmode == 1 ) then ! spherical dissipation r1 = v2h * wk2 ** ilap r2 = k2h * wk2 ** ilap else ! cylindrical dissipation r1 = v2h * kh ** ilap2 + v2z * kz ** ilap2 r2 = k2h * kh ** ilap2 + k2z * kz ** ilap2 endif if ( khn . le . kdamping ) then r1 = r1 + ek r2 = r2 + ek endif dpz = 1. + r1 / 2. dmz = 1. - r1 / 2. tzx = ( zxnk ( ikx , iky , ikz ) * dmz + D12 * ( 2 3. * termzx - 1 6. * zxok ( ikx , iky , ikz ) & + 5. * zx1k ( ikx , iky , ikz ) ) ) / dpz tzy = ( zynk ( ikx , iky , ikz ) * dmz + D12 * ( 2 3. * termzy - 1 6. * zyok ( ikx , iky , ikz ) & + 5. * zy1k ( ikx , iky , ikz ) ) ) / dpz tzz = ( zznk ( ikx , iky , ikz ) * dmz + D12 * ( 2 3. * termzz - 1 6. * zzok ( ikx , iky , ikz ) & + 5. * zz1k ( ikx , iky , ikz ) ) ) / dpz dpz = 1. + r2 / 2. dmz = 1. - r2 / 2. ttt = ( ttnk ( ikx , iky , ikz ) * dmz + D12 * ( 2 3. * termtt - 1 6. * ttok ( ikx , iky , ikz ) & + 5. * tt1k ( ikx , iky , ikz ) ) ) / dpz zx1k ( ikx , iky , ikz ) = zxok ( ikx , iky , ikz ) * L ( ikx , iky , ikz ) zy1k ( ikx , iky , ikz ) = zyok ( ikx , iky , ikz ) * L ( ikx , iky , ikz ) zz1k ( ikx , iky , ikz ) = zzok ( ikx , iky , ikz ) * L ( ikx , iky , ikz ) tt1k ( ikx , iky , ikz ) = ttok ( ikx , iky , ikz ) * L ( ikx , iky , ikz ) zxok ( ikx , iky , ikz ) = termzx * L ( ikx , iky , ikz ) zyok ( ikx , iky , ikz ) = termzy * L ( ikx , iky , ikz ) zzok ( ikx , iky , ikz ) = termzz * L ( ikx , iky , ikz ) ttok ( ikx , iky , ikz ) = termtt * L ( ikx , iky , ikz ) zxnk ( ikx , iky , ikz ) = tzx * L ( ikx , iky , ikz ) zynk ( ikx , iky , ikz ) = tzy * L ( ikx , iky , ikz ) zznk ( ikx , iky , ikz ) = tzz * L ( ikx , iky , ikz ) ttnk ( ikx , iky , ikz ) = ttt * L ( ikx , iky , ikz ) enddo enddo enddo ! ----------------------------------------------------------------- ! Diagnostics and i/o ! ----------------------------------------------------------------- ! Compute diagnostics if ( mod ( nt , ndiagevery ). eq . 0 ) then call wtoab ( zxnk , zynk , zznk , ttnk , geok , gw1k , gw2k , uk , vk , wk ) call proj ( zxnk , zynk , zznk ) call convol ( zxnk , zynk , zznk , ttnk , nzxk , nzyk , nzzk , nttk , uk , vk , wk , ur , vr , wr , & rhzx , rhzy , rhzz , rhtt , zxnr , zynr , zznr , ttnr , nzxr , nzyr , nzzr , nttr ) call do_diagnostics ( zxnk , zynk , zznk , ttnk , geok , gw1k , gw2k , nzxk , nzyk , nzzk , nttk , rhzx , rhzy , rhzz , rhtt , uk , vk , wk , nt ) endif ! ndiagevery if ( ( realspace_flag . ne . 0 ) . and . ( mod ( nt , nrsevery ). eq . 0 ) . and . ( iRScount . lt . nrsout ) ) then call dump_realspace ( zxnk , zynk , zznk , ttnk , uk , vk , wk , zxnr , zynr , zznr , ttnr , ur , vr , wr ) endif end do ! nt ! Write to restart file if ( ncwrite == 1 ) then call ncdumpout ( zxnk , zynk , zznk , ttnk ) endif ! ncwrite if ( realspace_flag . ne . 0 ) call close_ncf_realspace () !!$  if (npts.gt.0) then !!$     call dump_timeseries(utseries,vtseries,zztseries,timetseries,mypoints,isample,nomypts) !!$     deallocate(mypoints) !!$     if (mype.eq.0) deallocate(timetseries) !!$     if ( (kpU.eq.1).and.(nomypts.gt.0) ) deallocate(utseries) !!$     if ( (kpV.eq.1).and.(nomypts.gt.0) ) deallocate(vtseries) !!$     if ( (kpZZ.eq.1).and.(nomypts.gt.0) ) deallocate(zztseries) !!$  endif ! destroy FFTW plans, free allocated memory. call fftwf_destroy_plan ( plan3_ur_uk ) call fftwf_destroy_plan ( plan3_vr_vk ) call fftwf_destroy_plan ( plan3_wr_wk ) call fftwf_destroy_plan ( plan3_zxnr_zxnk ) call fftwf_destroy_plan ( plan3_zynr_zynk ) call fftwf_destroy_plan ( plan3_zznr_zznk ) call fftwf_destroy_plan ( plan3_ttnr_ttnk ) call fftwf_destroy_plan ( plan3_nzxr_nzxk ) call fftwf_destroy_plan ( plan3_nzyr_nzyk ) call fftwf_destroy_plan ( plan3_nzzr_nzzk ) call fftwf_destroy_plan ( plan3_uk_ur ) call fftwf_destroy_plan ( plan3_vk_vr ) call fftwf_destroy_plan ( plan3_wk_wr ) call fftwf_destroy_plan ( plan3_zxnk_zxnr ) call fftwf_destroy_plan ( plan3_zynk_zynr ) call fftwf_destroy_plan ( plan3_zznk_zznr ) call fftwf_destroy_plan ( plan3_ttnk_ttnr ) call fftwf_mpi_cleanup () call fftwf_free ( zxo_p ) call fftwf_free ( zyo_p ) call fftwf_free ( zzo_p ) call fftwf_free ( tto_p ) call fftwf_free ( zxn_p ) call fftwf_free ( zyn_p ) call fftwf_free ( zzn_p ) call fftwf_free ( ttn_p ) call fftwf_free ( nzx_p ) call fftwf_free ( nzy_p ) call fftwf_free ( nzz_p ) call fftwf_free ( ntt_p ) call fftwf_free ( u_p ) call fftwf_free ( v_p ) call fftwf_free ( w_p ) deallocate ( L ) deallocate ( kxa ) deallocate ( kya ) deallocate ( kza ) deallocate ( rhzx ) deallocate ( rhzy ) deallocate ( rhzz ) deallocate ( rhtt ) deallocate ( geok ) deallocate ( gw1k ) deallocate ( gw2k ) deallocate ( zx1k ) deallocate ( zy1k ) deallocate ( zz1k ) deallocate ( tt1k ) call mpi_finalize ( istatus ) end PROGRAM MAIN !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc ! INITIALIZING THE PARAMETERS !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc subroutine init_params () ! Initialises wavenumbers (kxa, kya and kza) and the mask array L(:,:,:) use param implicit none integer :: ikx , iky , ikz , ikza , jj real :: kx , ky , kz , wk , kh ! Initialize wavenumber arrays do ikx = 1 , iktx kxa ( ikx ) = float ( ikx - 1 ) * twopi / L1 enddo do iky = 1 , ikty jj = iky - 1 if ( iky . gt . kty ) jj = jj - 2 * kty if ( iky . eq . kty + 1 ) jj = 0 if ( iky . gt . 2 * kty ) jj = 0 kya ( iky ) = float ( jj ) * twopi / L2 enddo do ikz = 1 , iktz jj = ikz - 1 if ( ikz . gt . ktz ) jj = jj - 2 * ktz if ( ikz . eq . ktz + 1 ) jj = 0 if ( ikz . gt . 2 * ktz ) jj = 0 kza ( ikz ) = float ( jj ) * twopi / L3 ! if (mype.eq.0) print*,ikz,kza(ikz) enddo ! L(ikx,iky,ikz) is unity for retained modes and zero beyond the truncation, ! at k=0 and for half the modes on the plane kx=0. L = 1 do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) kh = sqrt ( kx * kx + ky * ky ) wk = kx * kx + ky * ky + kz * kz wk = sqrt ( wk ) ! Set L=0 where necessary: if ( iky . eq . kty + 1 ) L ( ikx , iky , ikz ) = 0 if ( ikza . eq . ktz + 1 ) L ( ikx , iky , ikz ) = 0 if ( kx . lt . 0 ) L ( ikx , iky , ikz ) = 0 if ( kx . eq . 0 . and . ky . lt . 0 ) L ( ikx , iky , ikz ) = 0 if ( kx . eq . 0 . and . ky . eq . 0 . and . kz . lt . 0 ) L ( ikx , iky , ikz ) = 0 if ( iky . gt . 2 * kty ) L ( ikx , iky , ikz ) = 0 if ( ikza . gt . 2 * ktz ) L ( ikx , iky , ikz ) = 0 if ( truncmode == 1 ) then ! spherical truncation if ( wk . eq . 0. . or . wk . gt . ifix ( KTRUNC_X + 0.5 ) - 0.5 ) L ( ikx , iky , ikz ) = 0 if ( wk . eq . 0. . or . ( wk * L1 / twopi ). gt . ifix ( float ( n1 ) / 3. + 0.5 ) - 0.5 ) L ( ikx , iky , ikz ) = 0 else ! cylindrical truncation if ( wk . eq . 0. . or . ( kh * L1 / twopi ). gt . int ( float ( n1 ) / 3. + 0.5 ) - 0.5 ) L ( ikx , iky , ikz ) = 0 if ( abs ( kz * L3 / twopi ). gt . int ( float ( n3 ) / 3. + 0.5 ) - 0.5 ) L ( ikx , iky , ikz ) = 0 endif ! cubic truncation !!$        if (wk.eq.0.)                                                     L(ikx,iky,ikz) = 0 !!$        if (wk.eq.0. .or. wk.gt.ifix(KTRUNC_X + 0.5) - 0.5)                L(ikx,iky,ikz) = 0 !!$        if (abs(kx*L1/twopi).gt.int(float(n1)/3. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !!$        if (abs(ky*L2/twopi).gt.int(float(n2)/3. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !!$        if (abs(kz*L3/twopi).gt.int(float(n3)/3. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !!!    ! cubic truncation with 8/9 instead of 2/3 truncation !!$         if (abs(kx*L1/twopi).gt.int(float(n1)*4./9. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !!$         if (abs(ky*L2/twopi).gt.int(float(n2)*4./9. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !!$         if (abs(kz*L3/twopi).gt.int(float(n3)*4./9. + 0.5)-0.5)              L(ikx,iky,ikz) = 0 !         if (abs(kx*L1/twopi).gt.255.)              L(ikx,iky,ikz) = 0 !         if (abs(ky*L2/twopi).gt.255.)              L(ikx,iky,ikz) = 0 !         if (abs(kz*L3/twopi).gt.255.)              L(ikx,iky,ikz) = 0 enddo enddo enddo end subroutine init_params subroutine energy_full ( zx , zy , zz , tt , ux , uy , uz , ge , g1 , g2 , ke , pe , eg , ea ) ! Computes total energy (KE, PE, VE, WE) use param use velvorproj use nm_decomp implicit none include 'mpif.h' complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: ux , uy , uz , ge , g1 , g2 real , intent ( out ) :: ke , pe , eg , ea integer :: ikx , iky , ikz , ikza real :: kx , ky , kz , wk , wkh2 , wkh2n , kzn real :: vh , vzx , vzy , vzz , vz real :: zero_kz_geo , zero_kz_grv , zero_kh_grv , zero_kh_geo , tmp call velo ( zx , zy , zz , ux , uy , uz ) call wtoab ( zx , zy , zz , tt , ge , g1 , g2 , ux , uy , uz ) zero_kz_geo = 0. zero_kz_grv = 0. zero_kh_geo = 0. zero_kh_grv = 0. ke = 0. pe = 0. eg = 0. ea = 0. do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) kzn = kz * L3 / twopi do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wkh2 = kx * kx + ky * ky wkh2n = wkh2 * ( L1 / twopi ) ** 2 wk = kx * kx + ky * ky + kz * kz if ( L ( ikx , iky , ikz ). eq . 1 ) then wk = max ( wk , 1.e-15 ) wkh2 = max ( wkh2 , 1.e-15 ) vzx = real ( zx ( ikx , iky , ikz ) * conjg ( zx ( ikx , iky , ikz )) ) ke = ke + vzx / wk vzy = real ( zy ( ikx , iky , ikz ) * conjg ( zy ( ikx , iky , ikz )) ) ke = ke + vzy / wk vzz = real ( zz ( ikx , iky , ikz ) * conjg ( zz ( ikx , iky , ikz )) ) ke = ke + vzz / wk vh = real ( tt ( ikx , iky , ikz ) * conjg ( tt ( ikx , iky , ikz )) ) pe = pe + vh vzx = real ( ux ( ikx , iky , ikz ) * conjg ( ux ( ikx , iky , ikz )) ) vzy = real ( uy ( ikx , iky , ikz ) * conjg ( uy ( ikx , iky , ikz )) ) vzz = real ( uz ( ikx , iky , ikz ) * conjg ( uz ( ikx , iky , ikz )) ) if ( wkh2n . lt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then zero_kh_grv = zero_kh_grv + vzx + vzy zero_kh_geo = zero_kh_geo + VH * aj / bj endif if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). lt . 1.e-10 ) then zero_kz_geo = zero_kz_geo + VZX + VZY zero_kz_grv = zero_kz_grv + VZZ + VH * aj / bj endif if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then vz = real ( ge ( ikx , iky , ikz ) * conjg ( ge ( ikx , iky , ikz ))) eg = eg + vz / wkh2 vz = real ( g1 ( ikx , iky , ikz ) * conjg ( g1 ( ikx , iky , ikz ))) ea = ea + vz / wkh2 vz = real ( g2 ( ikx , iky , ikz ) * conjg ( g2 ( ikx , iky , ikz ))) ea = ea + vz / wkh2 endif endif enddo enddo enddo if ( aj . ne . 0. . and . bj . ne . 0. ) pe = aj * pe / bj eg = eg + zero_kz_geo + zero_kh_geo ea = ea + zero_kz_grv + zero_kh_grv call mpi_allreduce ( ke , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); ke = tmp call mpi_allreduce ( pe , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); pe = tmp call mpi_allreduce ( eg , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); eg = tmp call mpi_allreduce ( ea , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); ea = tmp end subroutine energy_full subroutine cfl ( zx , zy , zz , ux , uy , uz , ur , vr , wr ) ! Computes and prints cfl number based on max velo use param use velvorproj use param_fftw implicit none complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: ux , uy , uz real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: ur , vr , wr real :: umax , wmax , tmp , dx , dz dx = L1 / float ( n1 ) * 1.5 dz = L3 / float ( n3 ) * 1.5 call velo ( zx , zy , zz , ux , uy , uz ) call fftwkr ( plan3_uk_ur , ux , ur ) call fftwkr ( plan3_vk_vr , uy , vr ) call fftwkr ( plan3_wk_wr , uz , wr ) umax = maxval ( abs ( ur )) umax = max ( umax , maxval ( abs ( vr ))) wmax = maxval ( abs ( wr )) call mpi_reduce ( umax , tmp , 1 , MPI_REAL , MPI_MAX , 0 , MPI_COMM_WORLD , istatus ) umax = tmp call mpi_reduce ( wmax , tmp , 1 , MPI_REAL , MPI_MAX , 0 , MPI_COMM_WORLD , istatus ) wmax = tmp umax = umax * delt / dx wmax = wmax * delt / dz if ( mype . eq . 0 ) write ( 6 , 5555 ) umax , wmax 5555 format ( 'Max CFL (x,z): ' , 2 ( f12 . 6 , 1 x )) end subroutine cfl !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc !c NONLINEAR TERMS !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc subroutine convol ( zxk , zyk , zzk , ttk , nxk , nyk , nzk , ntk , uk , vk , wk , ur , vr , wr , & wxk , wyk , wzk , wtk , zxr , zyr , zzr , ttr , nxr , nyr , nzr , ntr ) ! Nonlinear term in vorticity/temperature equation ! Uses scratch arrays wxk,wyk,wzk,wtk to avoid some ffts. ! Calculates convolution sums, calls ffts, etc. use param use velvorproj use param_fftw implicit none real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr , ur , vr , wr real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: nxr , nyr , nzr , ntr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zxk , zyk , zzk , ttk , uk , vk , wk , wxk , wyk , wzk , wtk complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: nxk , nyk , nzk , ntk integer :: ikx , iky , ikz , ikza real :: kx , ky , kz complex :: c1 , c2 , c3 ntk = cmplx ( 0. , 0. ) wxk = zxk wyk = zyk wzk = zzk wtk = ttk ! Nonlinear term in the temperature equation. call velo ( zxk , zyk , zzk , uk , vk , wk ) call fftwkr ( plan3_uk_ur , uk , ur ) call fftwkr ( plan3_vk_vr , vk , vr ) call fftwkr ( plan3_wk_wr , wk , wr ) call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) nxr = ur * ttr nyr = vr * ttr nzr = wr * ttr call fftwrk ( plan3_nzxr_nzxk , nxr , nxk ) call fftwrk ( plan3_nzyr_nzyk , nyr , nyk ) call fftwrk ( plan3_nzzr_nzzk , nzr , nzk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) ntk ( ikx , iky , ikz ) = - zi * ( kx * nxk ( ikx , iky , ikz ) & + ky * nyk ( ikx , iky , ikz ) & + kz * nzk ( ikx , iky , ikz ) ) * L ( ikx , iky , ikz ) enddo enddo enddo ! Nonlinear term in the vorticity equation. call fftwkr ( plan3_zxnk_zxnr , zxk , zxr ) call fftwkr ( plan3_zynk_zynr , zyk , zyr ) call fftwkr ( plan3_zznk_zznr , zzk , zzr ) nxr = wr * zyr - vr * zzr nyr = ur * zzr - wr * zxr nzr = vr * zxr - ur * zyr call fftwrk ( plan3_nzxr_nzxk , nxr , nxk ) call fftwrk ( plan3_nzyr_nzyk , nyr , nyk ) call fftwrk ( plan3_nzzr_nzzk , nzr , nzk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) c1 = ky * nzk ( ikx , iky , ikz ) - kz * nyk ( ikx , iky , ikz ) c2 = kz * nxk ( ikx , iky , ikz ) - kx * nzk ( ikx , iky , ikz ) c3 = kx * nyk ( ikx , iky , ikz ) - ky * nxk ( ikx , iky , ikz ) nxk ( ikx , iky , ikz ) = - zi * c1 * L ( ikx , iky , ikz ) nyk ( ikx , iky , ikz ) = - zi * c2 * L ( ikx , iky , ikz ) nzk ( ikx , iky , ikz ) = - zi * c3 * L ( ikx , iky , ikz ) enddo enddo enddo zxk = wxk zyk = wyk zzk = wzk ttk = wtk return end subroutine convol subroutine constr ( zxk , zyk , zzk , ttk , nxk , nyk , nzk , ntk , uk , vk , wk , ur , vr , wr , & zxr , zyr , zzr , ttr , nxr , nyr , nzr , ntr ) ! Nonlinear term in vorticity/temperature equation ! Like CONVOL but does not use scratch arrays, so requires a few extra FFTs. ! Calculates convolution sums, calls ffts, etc. without scratch arrays. use param use velvorproj use param_fftw implicit none real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr , ur , vr , wr real , intent ( out ), dimension ( n1d , n3d , n2dp ) :: nxr , nyr , nzr , ntr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zxk , zyk , zzk , ttk , uk , vk , wk complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: nxk , nyk , nzk , ntk integer :: ikx , iky , ikz , ikza real :: kx , ky , kz complex :: c1 , c2 , c3 ntr = cmplx ( 0. , 0. ) ! Nonlinear term in temperature equation. call velo ( zxk , zyk , zzk , uk , vk , wk ) call fftwkr ( plan3_uk_ur , uk , ur ) call fftwkr ( plan3_vk_vr , vk , vr ) call fftwkr ( plan3_wk_wr , wk , wr ) call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) ur = ur * ttr vr = vr * ttr wr = wr * ttr ! these calls not in convol: call fftwrk ( plan3_ur_uk , ur , uk ) call fftwrk ( plan3_vr_vk , vr , vk ) call fftwrk ( plan3_wr_wk , wr , wk ) call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) ntk ( ikx , iky , ikz ) = - ZI * ( kx * uk ( ikx , iky , ikz ) & + ky * vk ( ikx , iky , ikz ) & + kz * wk ( ikx , iky , ikz ) ) * L ( ikx , iky , ikz ) enddo enddo enddo ! Nonlinear term in vorticity equation. call velo ( zxk , zyk , zzk , uk , vk , wk ) call fftwkr ( plan3_uk_ur , uk , ur ) call fftwkr ( plan3_vk_vr , vk , vr ) call fftwkr ( plan3_wk_wr , wk , wr ) call fftwkr ( plan3_zxnk_zxnr , zxk , zxr ) call fftwkr ( plan3_zynk_zynr , zyk , zyr ) call fftwkr ( plan3_zznk_zznr , zzk , zzr ) nxr = wr * zyr - vr * zzr nyr = ur * zzr - wr * zxr nzr = vr * zxr - ur * zyr call fftwrk ( plan3_nzxr_nzxk , nxr , nxk ) call fftwrk ( plan3_nzyr_nzyk , nyr , nyk ) call fftwrk ( plan3_nzzr_nzzk , nzr , nzk ) call fftwrk ( plan3_zxnr_zxnk , zxr , zxk ) call fftwrk ( plan3_zynr_zynk , zyr , zyk ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) c1 = ky * nzk ( ikx , iky , ikz ) - kz * nyk ( ikx , iky , ikz ) c2 = kz * nxk ( ikx , iky , ikz ) - kx * nzk ( ikx , iky , ikz ) c3 = kx * nyk ( ikx , iky , ikz ) - ky * nxk ( ikx , iky , ikz ) nxk ( ikx , iky , ikz ) = - zi * c1 * L ( ikx , iky , ikz ) nyk ( ikx , iky , ikz ) = - zi * c2 * L ( ikx , iky , ikz ) nzk ( ikx , iky , ikz ) = - zi * c3 * L ( ikx , iky , ikz ) enddo enddo enddo return end subroutine constr !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc !c FFTS !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc subroutine fftwrk ( plan , zr , zk ) ! wrapper for real -> complex FFT.  Transforms zr -> zk ! Note, transforms are in place.  zr and zk must be equivalenced. ! So transform destroys zr use param use param_fftw implicit none real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zk type ( C_PTR ), intent ( in ) :: plan call fftwf_execute_dft_r2c ( plan , zr , zk ) ! Normalize zk = zk / fftnorm end subroutine fftwrk subroutine fftwkr ( plan , zk , zr ) ! wrapper for complex -> real IFFT.  Transforms zk -> zr ! Note, transforms are in place.  zr and zk must be equivalenced. ! So transform destroys zk use param use param_fftw implicit none complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zk real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zr type ( C_PTR ), intent ( in ) :: plan call realit ( zk ) !<---- IMPORTANT! Necessary to populate some zeroed-out wavenumbers before transforming. call fftwf_execute_dft_c2r ( plan , zk , zr ) end subroutine fftwkr !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc !c RANDOM NUMBERS !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc function rang ( i ) ! If i ne 0 then initializes RANNO with seed = i ! If i eq 0 then draws a random GAUSSIAN number with ! mean and std = 1 implicit none real :: rang integer :: i real :: v1 , v2 , R , FAC , twopi , ranno external :: ranno twopi = 4. * asin ( 1. ) if ( i . ne . 0 ) then v1 = ranno ( i ) else 200 v1 = 2. * ( ranno ( 0 ) + twopi / 2. ) / twopi - 1. v2 = 2. * ( ranno ( 0 ) + twopi / 2. ) / twopi - 1. r = v1 ** 2. + v2 ** 2. if ( r . gt . 1. ) goto 200 fac = sqrt ( - 2. * log ( r ) / r ) rang = v1 * fac endif return end function rang function ranno ( i ) ! Controls random number generator. !----------------------------------------- ! - If argument i.ne.0 it performs initialization with i=seed no. ! - If argument i.eq.0 it draws a random no. !----------------------------------------- implicit none real :: ranno integer :: i integer :: junk , ihold real :: twopi , ran1 save junk twopi = 4. * asin ( 1. ) if ( i . ne . 0 ) then if ( i . gt . 0 ) i = - i junk = i ranno = ( ran1 ( i ) - 0.5 ) * twopi else junk = junk - 1 ihold = junk ranno = ( ran1 ( ihold ) - 0.5 ) * twopi endif return end function ranno function ran1 ( idum ) implicit none real :: ran1 integer :: idum integer , parameter :: ia = 16807 , im = 2147483647 , iq = 127773 , ir = 2836 , ntab = 32 , ndiv = 1 + ( im - 1 ) / ntab real , parameter :: am = 1. / im , eps = 1.2e-7 , rnmx = 1. - eps integer :: j , k , iv ( 32 ), iy save iv , iy data iv / ntab * 0 / , iy / 0 / if ( idum . le . 0. or . iy . eq . 0 ) then idum = max ( - idum , 1 ) do j = ntab + 8 , 1 , - 1 k = idum / iq idum = ia * ( idum - k * iq ) - ir * k if ( idum . lt . 0 ) idum = idum + im if ( j . le . ntab ) iv ( j ) = idum enddo iy = iv ( 1 ) endif k = idum / iq idum = ia * ( idum - k * iq ) - ir * k if ( idum . lt . 0 ) idum = idum + im j = 1 + iy / ndiv iy = iv ( j ) iv ( j ) = idum ran1 = min ( am * iy , rnmx ) return end function ran1 !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc ! MISC SUBROUTINES !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc subroutine realit ( zk ) ! Enforces the reality condition on the plane kx=0 ! by writing on modes with L(ikx,iky,ikz) = 0. use param use param_fftw implicit none complex , intent ( inout ) :: zk ( iktx , ikty , iktzp ) integer , parameter :: iktyh = ikty / 2 integer :: n2h , n3h integer :: ikx , iky , ikz , kz , inkz , ky , inky integer :: status ( MPI_STATUS_SIZE ) complex :: buf1 ( iktyh , iktzp - 1 ), buf2 ( iktyh ) integer :: nto , nfrom , nbuf1 , nbuf2 , nph nph = npe / 2 nbuf1 = iktyh * ( iktzp - 1 ) nbuf2 = iktyh n2h = n2 / 2 n3h = n3 / 2 ! First, negative ky axis; no communication required ! Set zk(0,-ky,0) = conjg(zk(0,ky,0)) if ( mype . eq . 0 ) then ikx = 1 ikz = 1 do ky = 1 , n2h - 1 iky = n2h + 1 - ky inky = n2h + 1 + ky zk ( ikx , inky , ikz ) = conjg ( zk ( ikx , iky , ikz ) ) enddo endif ! Next, send kz>0,ky>=0 to kz<0,ky<=0 ! Write zk(0,-ky,-kz) = conjg(zk(0,ky, kz)) ! Have to do it in 2 parts if ( mype . le . nph - 1 ) then nto = npe - mype - 1 buf1 = zk ( 1 , 1 : ikty / 2 , 2 : iktzp ) call mpi_send ( buf1 , nbuf1 , MPI_COMPLEX , nto , 1 , MPI_COMM_WORLD , istatus ) else nfrom = npe - mype - 1 call mpi_recv ( buf1 , nbuf1 , MPI_COMPLEX , nfrom , 1 , MPI_COMM_WORLD , status , istatus ) ikx = 1 do kz = 2 , iktzp ikz = kz - 1 inkz = iktzp + 2 - kz iky = 1 zk ( ikx , iky , inkz ) = conjg ( buf1 ( iky , ikz ) ) ! do ky=0 do ky = 1 , n2h - 1 iky = n2h + 1 - ky inky = n2h + 1 + ky zk ( ikx , inky , inkz ) = conjg ( buf1 ( iky , ikz ) ) enddo enddo endif if (( mype . gt . 0 ). and .( mype . le . nph - 1 )) then nto = npe - mype buf2 = zk ( 1 , 1 : ikty / 2 , 1 ) call mpi_send ( buf2 , nbuf2 , MPI_COMPLEX , nto , 1 , MPI_COMM_WORLD , istatus ) endif if ( mype . gt . nph ) then nfrom = npe - mype call mpi_recv ( buf2 , nbuf2 , MPI_COMPLEX , nfrom , 1 , MPI_COMM_WORLD , status , istatus ) ikx = 1 inkz = 1 iky = 1 zk ( ikx , iky , inkz ) = conjg ( buf2 ( iky ) ) ! do ky=0 do ky = 1 , n2h - 1 iky = n2h + 1 - ky inky = n2h + 1 + ky zk ( ikx , inky , inkz ) = conjg ( buf2 ( iky ) ) enddo endif ! Finally, send kz<0,ky>=0 to kz>0,ky<=0 ! Write zk(0,-ky,kz) = conjg(zk(0,ky,-kz)) ! Have to do it in 2 parts if ( mype . ge . nph ) then nto = npe - mype - 1 buf1 = zk ( 1 , 1 : ikty / 2 , 2 : iktzp ) call mpi_send ( buf1 , nbuf1 , MPI_COMPLEX , nto , 1 , MPI_COMM_WORLD , istatus ) else nfrom = npe - mype - 1 call mpi_recv ( buf1 , nbuf1 , MPI_COMPLEX , nfrom , 1 , MPI_COMM_WORLD , status , istatus ) ikx = 1 do kz = 2 , iktzp ikz = kz - 1 inkz = iktzp + 2 - kz iky = 1 do ky = 1 , n2h - 1 iky = n2h + 1 - ky inky = n2h + 1 + ky zk ( ikx , inky , inkz ) = conjg ( buf1 ( iky , ikz ) ) enddo enddo endif if ( mype . gt . nph ) then nto = npe - mype buf2 = zk ( 1 , 1 : ikty / 2 , 1 ) call mpi_send ( buf2 , nbuf2 , MPI_COMPLEX , nto , 1 , MPI_COMM_WORLD , istatus ) endif if (( mype . gt . 0 ). and .( mype . le . nph - 1 )) then nfrom = npe - mype call mpi_recv ( buf2 , nbuf2 , MPI_COMPLEX , nfrom , 1 , MPI_COMM_WORLD , status , istatus ) ikx = 1 inkz = 1 iky = 1 do ky = 1 , n2h - 1 iky = n2h + 1 - ky inky = n2h + 1 + ky zk ( ikx , inky , inkz ) = conjg ( buf2 ( iky ) ) enddo endif return end subroutine realit","tags":"","loc":"sourcefile/boussinesq.f90.html"},{"title":"IO_netcdf.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module contains function used to read the main field from a restart file or             !!\nstore the field for future restarts. Everything is in NetCDF format                          !!\nncreadin may be used in init_condition.F90 to generate the Initial Condition                 !!\nncdumpout used in the main code (boussinesq.F90) to create the output for future restarts    !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module contains function used to read the main field from a restart file or             !! !! store the field for future restarts. Everything is in NetCDF format                          !! !! ncreadin may be used in init_condition.F90 to generate the Initial Condition                 !! !! ncdumpout used in the main code (boussinesq.F90) to create the output for future restarts    !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module IO_netcdf use param use netcdf implicit none integer :: idink , idoutk , idkx , idky , idkz , idkri , idktm , istat integer :: idzxk , idzyk , idzzk , idttk , idtimek CONTAINS subroutine check ( status ) integer , intent ( in ) :: status if ( status /= nf90_noerr ) then print * , 'ERROR in IO_netcdf.F90' print * , trim ( nf90_strerror ( status )) stop \"Stopped!!!\" end if end subroutine check subroutine ncdumpout ( zx , zy , zz , tt ) !! Create netcdf files and write the fields for restart (output) !! Only zx,zy,zz and tt are dumped in a netcdf file implicit none include 'mpif.h' complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt integer , dimension ( 4 ) :: ncdimsk integer , dimension ( 4 ) :: nccountk , ncstartk !--------------------------------------------------------------------- !     DEFINING THE OUTPUT NETCDF FILE !!! prep restart file (output) (define the variables and dims) if ( mype . eq . 0 ) print * , 'Yo! dumping in netcdf restart file' ! Create the netCDF file. The nf90_clobber parameter tells netCDF, ! just to be safe \"nf90_64bit_offset\" is used for large data, but it seems unnecessary for netCDF4 version call check ( nf90_create ( \"Zk.out.ncf\" , ior ( NF90_NETCDF4 , NF90_MPIIO ), idoutk , & comm = MPI_COMM_WORLD , info = MPI_INFO_NULL ) ) ! Define the dimension: kx, ky, kz. time. RI used as another dim to distinguish between real and imag parts call check ( nf90_def_dim ( idoutk , \"kx\" , int ( iktx , 4 ), idkx ) ) call check ( nf90_def_dim ( idoutk , \"ky\" , int ( ikty , 4 ), idky ) ) call check ( nf90_def_dim ( idoutk , \"kz\" , int ( iktz , 4 ), idkz ) ) call check ( nf90_def_dim ( idoutk , \"RI\" , 2 , idkri ) ) call check ( nf90_def_dim ( idoutk , \"t\" , 1 , idktm ) ) ! ncdimsk array used to pass the dimension IDs to the variables ncdimsk = ( / idkx , idky , idkz , idkri / ) ! Define the variables which are the fields that going to be stored ! i.e. zx, zy, zz and tt call check ( nf90_def_var ( idoutk , \"zx\" , NF90_FLOAT , ncdimsk , idzxk )) call check ( nf90_def_var ( idoutk , \"zy\" , NF90_FLOAT , ncdimsk , idzyk )) call check ( nf90_def_var ( idoutk , \"zz\" , NF90_FLOAT , ncdimsk , idzzk )) call check ( nf90_def_var ( idoutk , \"tt\" , NF90_FLOAT , ncdimsk , idttk )) call check ( nf90_def_var ( idoutk , \"time\" , NF90_FLOAT , idktm , idtimek )) ! End define mode. This tells netCDF we are done defining metadata. call check ( nf90_enddef ( idoutk ) ) !--------------------------------------------------------------------- !     WRITING VARIABLES IN NETCDF FILE ! how many to count in each dimension when writing files nccountk ( 1 ) = iktx nccountk ( 2 ) = ikty nccountk ( 3 ) = iktzp nccountk ( 4 ) = 1 ! where to start on the output file ncstartk ( 1 ) = 1 ncstartk ( 2 ) = 1 call check ( nf90_put_var ( idoutk , idzxk , real ( zx )) ) ! wrtie time (time is written only one time so just root process is used if ( mype . eq . 0 ) then call check ( nf90_put_var ( idoutk , idtimek , time ) ) endif ! in the z-direction mype=0 is in the first place ncstartk ( 3 ) = mype * iktzp + 1 ncstartk ( 4 ) = 1 ! (real part) call check ( nf90_put_var ( idoutk , idzxk , real ( zx ), ncstartk , nccountk )) call check ( nf90_put_var ( idoutk , idzyk , real ( zy ), ncstartk , nccountk )) call check ( nf90_put_var ( idoutk , idzzk , real ( zz ), ncstartk , nccountk )) call check ( nf90_put_var ( idoutk , idttk , real ( tt ), ncstartk , nccountk )) ncstartk ( 4 ) = 2 ! (imag part) call check ( nf90_put_var ( idoutk , idzxk , aimag ( zx ), ncstartk , nccountk )) call check ( nf90_put_var ( idoutk , idzyk , aimag ( zy ), ncstartk , nccountk )) call check ( nf90_put_var ( idoutk , idzzk , aimag ( zz ), ncstartk , nccountk )) call check ( nf90_put_var ( idoutk , idttk , aimag ( tt ), ncstartk , nccountk )) !--------------------------------------------------------------------- !     CLOSING the  NETCDF FILE call check ( nf90_close ( idoutk )) end subroutine ncdumpout subroutine ncreadin ( zx , zy , zz , tt , ts ) ! Read the netcdf data from an input file (Zk.in.ncf) implicit none include 'mpif.h' complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt real , dimension ( iktx , ikty , iktzp ) :: wr , wi real , intent ( out ) :: ts integer :: iktx1 , ikty1 , iktz1 integer , dimension ( 5 ) :: ncstartr , ncstarti , nccount ! Open the file. NF90_NOWRITE tells netCDF we want read-only access if ( mype == 0 ) print * , 'Yo! reading from netcdf restart file' call check ( nf90_open ( 'Zk.in.ncf' , NF90_NOWRITE , idink ) ) ! Get the dimensions IDs based on their name call check ( nf90_inq_dimid ( idink , \"kx\" , idkx ) ) call check ( nf90_inq_dimid ( idink , \"ky\" , idky ) ) call check ( nf90_inq_dimid ( idink , \"kz\" , idkz ) ) call check ( nf90_inq_dimid ( idink , \"RI\" , idkri ) ) call check ( nf90_inq_dimid ( idink , \"t\" , idktm ) ) ! Get the dimension length and check if the grid resolution matches call check ( nf90_inquire_dimension ( idink , idkx , len = iktx1 )) call check ( nf90_inquire_dimension ( idink , idky , len = ikty1 )) call check ( nf90_inquire_dimension ( idink , idkz , len = iktz1 )) if ( iktx1 . ne . iktx . or . ikty1 . ne . ikty . or . iktz1 . ne . iktz ) then print * , 'Sorry, do not know how to change resolution.' stop endif ! Get the variables IDs call check ( nf90_inq_varid ( idink , \"time\" , idtimek )) call check ( nf90_inq_varid ( idink , \"zx\" , idzxk ) ) call check ( nf90_inq_varid ( idink , \"zy\" , idzyk ) ) call check ( nf90_inq_varid ( idink , \"zz\" , idzzk ) ) call check ( nf90_inq_varid ( idink , \"tt\" , idttk ) ) ! prepare for reading variables ncstartr = 1 ncstarti = 1 ncstarti ( 4 ) = 2 ! for imag part start from 2 for dim = 4 nccount ( 1 ) = iktx nccount ( 2 ) = ikty nccount ( 3 ) = iktzp nccount ( 4 ) = 1 ncstartr ( 3 ) = int ( mype * iktzp + 1 ) ncstarti ( 3 ) = int ( mype * iktzp + 1 ) call check ( nf90_get_var ( idink , idtimek , ts )) call check ( nf90_get_var ( idink , idzxk , wr , ncstartr , nccount )) call check ( nf90_get_var ( idink , idzxk , wi , ncstarti , nccount )) zx = wr + zi * wi call check ( nf90_get_var ( idink , idzyk , wr , ncstartr , nccount )) call check ( nf90_get_var ( idink , idzyk , wi , ncstarti , nccount )) zy = wr + zi * wi call check ( nf90_get_var ( idink , idzzk , wr , ncstartr , nccount )) call check ( nf90_get_var ( idink , idzzk , wi , ncstarti , nccount )) zz = wr + zi * wi call check ( nf90_get_var ( idink , idttk , wr , ncstartr , nccount )) call check ( nf90_get_var ( idink , idttk , wi , ncstarti , nccount )) tt = wr + zi * wi call check ( nf90_close ( idink )) end subroutine ncreadin end module IO_netcdf","tags":"","loc":"sourcefile/io_netcdf.f90.html"},{"title":"realspacedumpsUVall.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module dumps subspaces of real (physcial) space in the file 'realspace.ncf'             !!\nAt the moment is limited to 2D slices in physical(real) but can be extended to 3D subsets    !!\nIt can be customised to store one of the fields below                                        !!\nvorticity component, temperature, velocity component                                         !!\nother fields can also be stored                                                              !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module dumps subspaces of real (physcial) space in the file 'realspace.ncf'             !! !! At the moment is limited to 2D slices in physical(real) but can be extended to 3D subsets    !! !! It can be customised to store one of the fields below                                        !! !! vorticity component, temperature, velocity component                                         !! !! other fields can also be stored                                                              !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module realspacedumps2 use param use param_fftw use netcdf use velvorproj use nm_decomp implicit none !! %% PARAMETERs %% integer , parameter :: nHor = FLOOR ( real ( nHend - nHstart + 1.0 , 8 ) / nskipH ) integer , parameter :: nVer = FLOOR ( real ( nVend - nVstart + 1.0 , 8 ) / nskipV ) ! the location of slices integer , parameter :: ihor = n3 / 2 , iver = n1d / 2 ! Here we determine which fields are going to be stored ! Vorticity: ! horizontal slices integer , parameter :: kpZZHtot = 1 , kpZZHbrt = 1 ! vertical slices integer , parameter :: kpZZVtot = 0 , kpZZVbrt = 0 ! Velocities ! horizontal slices integer , parameter :: kpUUHtot = 1 , kpVVHtot = 1 , kpUUHbrc = 1 , kpVVHbrc = 1 , kpUUHbrt = 0 , kpVVHbrt = 0 ! vertical slices integer , parameter :: kpUUVtot = 0 , kpVVVtot = 0 , kpUUVbrc = 0 , kpVVVbrc = 0 ! Quadratic Nonlinear terms to derive pressure ! horizontal slices integer , parameter :: kpQDHtot = 0 , kpQDHbrc = 0 ! vertical slices integer , parameter :: kpQDVtot = 0 , kpQDVbrc = 0 !! %% VARIABLES %% ! NetCDF IDs integer , save :: idslices , idxrs , idyrs , idzrs , idtmrs , tmrid , xxid , yyid , zzid integer , save :: zzhtotid , zzvtotid , zzhbrtid , zzvbrtid integer , save :: uuhtotid , uuvtotid , vvhtotid , vvvtotid integer , save :: uuhbrcid , uuvbrcid , vvhbrcid , vvvbrcid integer , save :: uuhbrtid , vvhbrtid integer , save :: qdhtotid , qdvtotid , qdhbrcid , qdvbrcid integer , save :: iRScount ! counter when real space fields are dumped !! Make internal variables and functions private PRIVATE :: kpZZHtot , kpZZHbrt , kpZZVtot , kpZZVbrt PRIVATE :: kpUUHtot , kpVVHtot , kpUUHbrc , kpVVHbrc PRIVATE :: kpUUVtot , kpVVVtot , kpUUVbrc , kpVVVbrc PRIVATE :: kpUUHbrt , kpVVHbrt PRIVATE :: kpQDHtot , kpQDHbrc , kpQDVtot , kpQDVbrc PRIVATE :: check_rs CONTAINS subroutine check_rs ( sstatus ) implicit none include 'mpif.h' integer , intent ( in ) :: sstatus if ( sstatus /= nf90_noerr ) then print * , 'ERROR in realspacedumps.F90' print * , trim ( nf90_strerror ( sstatus )) call MPI_Abort ( MPI_COMM_WORLD ) end if end subroutine check_rs subroutine prep_realslice () ! creates a netcdf file for slices of fields in real (physical) space. implicit none include 'mpif.h' !!$  real, dimension(nHor):: xr,yr !!$  real, dimension(nVer):: zr real :: xr , yr , zr integer :: ix , iy , iz , ix1 , iy1 , iz1 iRScount = 0 if (( iver . gt . n2 ). or .( ihor . gt . n3 )) then print * , '----------- the slice index out of bound -----------------' endif if ( mod ( n2dp , nskipH ). ne . 0 ) then print * , '----------- cannot handle this skipping: n2dp cannot be divided by nskipH -----------------' endif istatus = nf90_create ( \"realspace.ncf\" , ior ( NF90_NETCDF4 , NF90_MPIIO ), & idslices , comm = MPI_COMM_WORLD , info = MPI_INFO_NULL ) if ( istatus . ne . 0 ) print * , 'Yo! error in creating realspace.ncf! Darn!' ! Define the dimensions of space and time call check_rs ( nf90_def_dim ( idslices , \"xxrs\" , nHor , idxrs )) call check_rs ( nf90_def_dim ( idslices , \"yyrs\" , nHor , idyrs )) call check_rs ( nf90_def_dim ( idslices , \"zzrs\" , nVer , idzrs )) call check_rs ( nf90_def_dim ( idslices , \"timers\" , nrsout + 1 , idtmrs )) ! nsp2dout+ >>1<< for dumping IC ! Define the time variable and spatial coordinates call check_rs ( nf90_def_var ( idslices , \"vartime\" , NF90_FLOAT ,( / idtmrs / ), tmrid )) call check_rs ( nf90_def_var ( idslices , \"varxx\" , NF90_FLOAT ,( / idxrs / ), xxid )) call check_rs ( nf90_def_var ( idslices , \"varyy\" , NF90_FLOAT ,( / idyrs / ), yyid )) call check_rs ( nf90_def_var ( idslices , \"varzz\" , NF90_FLOAT ,( / idzrs / ), zzid )) ! Define the variables for the slices that are supposed to be stored ! i.e. zx, zy, zz and tt if ( kpZZHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), zzhtotid ) endif if ( kpZZVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), zzvtotid ) endif if ( kpZZHbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZHbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), zzhbrtid ) endif if ( kpZZVbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"ZZVbrt\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), zzvbrtid ) endif if ( kpUUHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhtotid ) endif if ( kpUUVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), uuvtotid ) endif if ( kpVVHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhtotid ) endif if ( kpVVVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVVtot\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), vvvtotid ) endif if ( kpUUHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhbrcid ) endif if ( kpUUVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUVbrc\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), uuvbrcid ) endif if ( kpVVHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhbrcid ) endif if ( kpVVVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVVbrc\" , NF90_FLOAT ,( / idyrs , idzrs , idtmrs / ), vvvbrcid ) endif if ( kpUUHbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"UUHbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), uuhbrtid ) endif if ( kpVVHbrt . eq . 1 ) then istatus = nf90_def_var ( idslices , \"VVHbrt\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), vvhbrtid ) endif if ( kpQDHtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDHtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdhtotid ) endif if ( kpQDVtot . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDVtot\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdvtotid ) endif if ( kpQDHbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDHbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdhbrcid ) endif if ( kpQDVbrc . eq . 1 ) then istatus = nf90_def_var ( idslices , \"QDVbrc\" , NF90_FLOAT ,( / idxrs , idyrs , idtmrs / ), qdvbrcid ) endif call check_rs ( nf90_enddef ( idslices ) ) ! put values in spatial coordinate variables i.e. varxx and varyy vectors if ( mype . eq . 0 ) then ix1 = 0 iy1 = 0 iz1 = 0 do ix = nHstart , nHend , nskipH ix1 = ix1 + 1 xr = ( real ( ix ) - 1.0 ) / ( real ( n1 ) - 1.0 ) * L1 - L1 / 2.0 istatus = nf90_put_var ( idslices , xxid , xr , start = ( / ix1 / )) if ( istatus . ne . 0 ) print * , 'Yo! we fucked up xr! Darn!' enddo do iy = nHstart , nHend , nskipH iy1 = iy1 + 1 yr = ( real ( iy ) - 1.0 ) / ( real ( n2d ) - 1.0 ) * L2 - L2 / 2.0 call check_rs ( nf90_put_var ( idslices , yyid , yr , start = ( / iy1 / )) ) enddo do iz = nVstart , nVend , nskipV iz1 = iz1 + 1 zr = ( real ( iz ) - 1.0 ) / ( real ( n3d ) - 1.0 ) * L3 - L3 / 2.0 call check_rs ( nf90_put_var ( idslices , zzid , zr , start = ( / iz1 / )) ) enddo endif return end subroutine prep_realslice subroutine dump_realspace ( zxk , zyk , zzk , ttk , uk , vk , wk , zxr , zyr , zzr , ttr , ur , vr , wr ) implicit none include 'mpif.h' real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr , ur , vr , wr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zxk , zyk , zzk , ttk , uk , vk , wk complex , dimension ( iktx , ikty , iktzp ) :: zxaux , zyaux , zzaux , ttaux , qdk , ukbrt , vkbrt integer :: ikz , ikza , ikx , iky real :: kz , kx , ky iRScount = iRScount + 1 if ( mype . eq . 0 ) istatus = nf90_put_var ( idslices , tmrid , time , start = ( / iRScount / )) zzaux = zzk zxaux = zxk zyaux = zyk ttaux = ttk call fftwkr ( plan3_zznk_zznr , zzk , zzr ) if ( kpZZHtot . eq . 1 ) call dump_horslice ( zzr , zzhtotid ) if ( kpZZVtot . eq . 1 ) call dump_verslice ( zzr , zzvtotid ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) ! First store the total velocities call velo ( zxk , zyk , zzk , uk , vk , wk ) call fftwkr ( plan3_uk_ur , uk , ur ) if ( kpUUHtot . eq . 1 ) call dump_horslice ( ur , uuhtotid ) if ( kpUUVtot . eq . 1 ) call dump_verslice ( ur , uuvtotid ) zxr = ur call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) if ( kpVVHtot . eq . 1 ) call dump_horslice ( vr , vvhtotid ) if ( kpVVVtot . eq . 1 ) call dump_verslice ( vr , vvvtotid ) zyr = vr call fftwrk ( plan3_vr_vk , vr , vk ) ! Derive the quadratic nonlinear terms for calculating pressure (using total vel.) qdk = cmplx ( 0. , 0. ) ttr = zxr * zxr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- kx * kx * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttr = zxr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- 2 * kx * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttr = zyr * zyr call fftwrk ( plan3_ttnr_ttnk , ttr , ttk ) do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then ttk ( ikx , iky , ikz ) =- ky * ky * ttk ( ikx , iky , ikz ) else ttk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo qdk = qdk + ttk ttk = qdk call fftwkr ( plan3_ttnk_ttnr , ttk , ttr ) if ( kpQDHtot . eq . 1 ) call dump_horslice ( ttr , qdhtotid ) if ( kpQDVtot . eq . 1 ) call dump_verslice ( ttr , qdvtotid ) zxk = cmplx ( 0. , 0. ) zyk = cmplx ( 0. , 0. ) ! Derive the baroclinic velocities and store them ukbrt = uk vkbrt = vk do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) if ( abs ( kz ). lt . 1e-4 ) then uk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) vk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) else zzk ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) ukbrt ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) vkbrt ( ikx , iky , ikz ) = cmplx ( 0. , 0. ) endif enddo enddo enddo call fftwkr ( plan3_zznk_zznr , zzk , zzr ) if ( kpZZHbrt . eq . 1 ) call dump_horslice ( zzr , zzhbrtid ) if ( kpZZVbrt . eq . 1 ) call dump_verslice ( zzr , zzvbrtid ) call fftwrk ( plan3_zznr_zznk , zzr , zzk ) call fftwkr ( plan3_uk_ur , uk , ur ) if ( kpUUHbrc . eq . 1 ) call dump_horslice ( ur , uuhbrcid ) if ( kpUUVbrc . eq . 1 ) call dump_verslice ( ur , uuvbrcid ) call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) if ( kpVVHbrc . eq . 1 ) call dump_horslice ( vr , vvhbrcid ) if ( kpVVVbrc . eq . 1 ) call dump_verslice ( vr , vvvbrcid ) call fftwrk ( plan3_vr_vk , vr , vk ) uk = ukbrt vk = vkbrt call fftwkr ( plan3_uk_ur , uk , ur ) if ( kpUUHbrt . eq . 1 ) call dump_horslice ( ur , uuhbrtid ) call fftwrk ( plan3_ur_uk , ur , uk ) call fftwkr ( plan3_vk_vr , vk , vr ) if ( kpVVHbrt . eq . 1 ) call dump_horslice ( vr , vvhbrtid ) call fftwrk ( plan3_vr_vk , vr , vk ) zzk = zzaux zxk = zxaux zyk = zyaux ttk = ttaux return end subroutine dump_realspace subroutine dump_horslice ( fr , idhvar ) implicit none include 'mpif.h' real , intent ( in ), dimension ( n1d , n3d , n2dp ) :: fr real , dimension ( n1d , n2dp ) :: frslice , junk real , dimension ( n1d , n2d ) :: horvars integer , intent ( in ) :: idhvar integer , dimension ( 3 ) :: nccount , ncstart integer :: k , nsends , nbuf , iproc , istart integer :: status ( MPI_STATUS_SIZE ) nsends = npe - 1 do k = 1 , n2dp frslice (:, k ) = fr (:, ihor , k ) enddo nbuf = n1d * n2dp if ( mype . gt . 0 ) then call mpi_send ( frslice , nbuf , MPI_REAL , 0 , 137 , MPI_COMM_WORLD , istatus ) endif if ( mype . eq . 0 ) then horvars ( 1 : n1d , 1 : n2dp ) = frslice do iproc = 1 , nsends call mpi_recv ( junk , nbuf , MPI_REAL , MPI_ANY_SOURCE , 137 , MPI_COMM_WORLD , status , istatus ) istart = status ( MPI_SOURCE ) * n2dp do k = 1 , n2dp horvars ( 1 : n1d , istart + k ) = junk ( 1 : n1d , k ) enddo enddo ! print*, 'horvars(384,384) = ', horvars(384,384) call check_rs ( nf90_put_var ( idslices , idhvar , & horvars ( nHstart + 1 : nHend + 1 : nskipH , nHstart + 1 : nHend + 1 : nskipH ), & start = ( / 1 , 1 , iRScount / ), count = ( / nHor , nHor , 1 / ))) endif end subroutine dump_horslice subroutine dump_verslice ( fr , idvvar ) implicit none include 'mpif.h' real , intent ( in ), dimension ( n1d , n3d , n2dp ) :: fr integer , intent ( in ) :: idvvar real , dimension ( nHor , nVer ) :: vervars integer :: wantedmype , ix , iz , ix1 , iz1 wantedmype = floor (( iver - 1.0 ) / n2dp ) if ( wantedmype . eq . mype ) then iz1 = 0 do iz = nVstart , nVend , nskipV iz1 = iz1 + 1 ix1 = 0 do ix = nHstart + 1 , nHend + 1 , nskipH ix1 = ix1 + 1 vervars ( ix1 , iz1 ) = fr ( ix , iz , iver - wantedmype * n2dp ) end do end do call check_rs ( nf90_put_var ( idslices , idvvar , vervars , & start = ( / 1 , 1 , iRScount / ), count = ( / nHor , nVer , 1 / ))) endif end subroutine dump_verslice subroutine close_ncf_realspace () ! close creates a netcdf file for real space dumping implicit none include 'mpif.h' call check_rs ( nf90_close ( idslices ) ) return end subroutine close_ncf_realspace end module realspacedumps2","tags":"","loc":"sourcefile/realspacedumpsuvall.f90.html"},{"title":"misc.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module contains Normal Mode Decomposition as described in Bartello, 1995, J. Atmos. Sci.  !!\nThe subroutines in this module: wtoab, atowb                                                   !!\nModules used : param.F90 and velvorproj.F90                                                    !!\nRequired for: ncf2Dspc.F90 boussinesq.F90 (main file)                                          !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module contains Normal Mode Decomposition as described in Bartello, 1995, J. Atmos. Sci.  !! !! The subroutines in this module: wtoab, atowb                                                   !! !! Modules used : param.F90 and velvorproj.F90                                                    !! !! Required for: ncf2Dspc.F90 boussinesq.F90 (main file)                                          !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module misc use param use param_fftw implicit none CONTAINS subroutine printparameters () if ( mype . eq . 0 ) then write ( iuRESULT , * ) '                ' write ( iuRESULT , * ) '                ' write ( iuRESULT , * ) 'Parameters: ----------------------------------------------' write ( iuRESULT , * ) '              N1,N2,N3 =  ' , n1 , n2 , n3 write ( iuRESULT , * ) '              L1,L2,L3 =  ' , L1 , L2 , L3 write ( iuRESULT , * ) '              dx,dy,dz =  ' , L1 / n1 , L2 / n2 , L3 / n3 write ( iuRESULT , * ) '              IKTX,Y,Z =  ' , iktx , ikty , iktz write ( iuRESULT , * ) '                     KT = ' , ktrunc_x , ktrunc_y , ktrunc_z write ( iuRESULT , * ) 'Order of Laplacian diss.=  ' , ilap write ( iuRESULT , * ) '                  VISCH = ' , visch write ( iuRESULT , * ) '                  VISCZ = ' , viscz write ( iuRESULT , * ) '              tau_VISCH = ' , ( visch * ktrunc_x ** ilap2 ) ** ( - 1 ) write ( iuRESULT , * ) '              tau_VISCZ = ' , ( viscz * ktrunc_z ** ilap2 ) ** ( - 1 ) write ( iuRESULT , * ) '               Timestep = ' , delt write ( iuRESULT , * ) '     Integration length = ' , nstop * delt , ' = ' , nstop , ' DT.' write ( iuRESULT , * ) '       Output frequency = ' , ndiagevery * delt , ' = ' , ndiagevery , ' dt.' write ( iuRESULT , * ) '    ' write ( iuRESULT , * ) '    Thermal expansivity = ' , aj write ( iuRESULT , * ) '    Vertical T gradient = ' , bj write ( iuRESULT , * ) '    Brunt-Vaisala freq. = ' , sqrt ( bf2 ) write ( iuRESULT , * ) '     Coriolis parameter = ' , cor write ( iuRESULT , * ) '                ' write ( iuRESULT , * ) '                ' call flush ( iuRESULT ) endif end subroutine printparameters !!!!!!! unused routine for now kept here: !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc !c Misc subroutines for fast manifold (move to a module later) !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc subroutine pvcomp ( zxk , zyk , zzk , ttk , uk , vk , wk , zxr , zyr , zzr , ttr , ur , vr , wr ) ! calculating each term in Pv anamoly in real space and derivin the r.m.s ! note here n?k are derivatives of buoyance in x,y and z (not nonlinear terms) ! Hence make sure pvcomp is used when changing n?k does not affect the code ! like after at the end of all diagnostics such as spec and transf ... implicit none real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr real , intent ( inout ), dimension ( n1d , n3d , n2dp ) :: ur , vr , wr complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: zxk , zyk , zzk , ttk complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: uk , vk , wk complex , dimension ( iktx , ikty , iktzp ) :: axk , ayk , azk , bxk , byk , bzk integer :: ikx , iky , ikz , ikza integer :: ii , jj , kk real :: kx , ky , kz , term1a , term1 , term2 , term3 , term4 , allterms , tmp , maxzz complex :: bx , by external :: fftwrk , fftwkr axk = zxk ayk = zyk azk = zzk bxk = uk byk = vk bzk = wk do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) uk ( ikx , iky , ikz ) = ZI * kx * ttk ( ikx , iky , ikz ) * bf vk ( ikx , iky , ikz ) = ZI * ky * ttk ( ikx , iky , ikz ) * bf wk ( ikx , iky , ikz ) = ZI * kz * ttk ( ikx , iky , ikz ) * bf enddo enddo enddo call fftwkr ( plan3_uk_ur , uk , ur ) call fftwkr ( plan3_vk_vr , vk , vr ) call fftwkr ( plan3_wk_wr , wk , wr ) call fftwkr ( plan3_zxnk_zxnr , zxk , zxr ) call fftwkr ( plan3_zynk_zynr , zyk , zyr ) call fftwkr ( plan3_zznk_zznr , zzk , zzr ) !!$  term1=0 !!$  do ii= 1,n1d !!$     do jj= 1,n3d !!$        do kk= 1,n2dp !!$           term1 = term1 + zzr(ii,jj,kk)*zzr(ii,jj,kk) !!$        enddo !!$     enddo !!$  enddo term1 = sum (( zzr / cor ) * ( zzr / cor )) term2 = sum (( wr / bf2 ) * ( wr / bf2 )) term3 = sum ((( wr / bf2 ) * ( zzr / cor )) * (( wr / bf2 ) * ( zzr / cor ))) term4 = sum ((( ur / bf2 ) * ( zxr / cor ) + ( vr / bf2 ) * ( zyr / cor )) * & (( ur / bf2 ) * ( zxr / cor ) + ( vr / bf2 ) * ( zyr / cor ))) allterms = sum (( zzr / cor + wr / bf2 + ( wr / bf2 ) * ( zzr / cor ) + ( ur / bf2 ) * ( zxr / cor ) + ( vr / bf2 ) * ( zyr / cor )) & * ( zzr / cor + wr / bf2 + ( wr / bf2 ) * ( zzr / cor ) + ( ur / bf2 ) * ( zxr / cor ) + ( vr / bf2 ) * ( zyr / cor ))) call mpi_reduce ( term1 , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) term1 = sqrt ( tmp / float ( n1 * n2 * n3 )) call mpi_reduce ( term2 , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) term2 = sqrt ( tmp / float ( n1 * n2 * n3 )) call mpi_reduce ( term3 , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) term3 = sqrt ( tmp / float ( n1 * n2 * n3 )) call mpi_reduce ( term4 , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) term4 = sqrt ( tmp / float ( n1 * n2 * n3 )) call mpi_reduce ( allterms , tmp , 1 , MPI_REAL , MPI_SUM , 0 , MPI_COMM_WORLD , istatus ) allterms = sqrt ( tmp / float ( n1 * n2 * n3 )) if ( mype . eq . 0 ) then ! prep for output write ( 81 , 5045 ) time , term1 , term2 , term3 , term4 , allterms call flush ( 81 ) endif !!$  call fftwrk(plan3_zxnr_zxnk,zxr,zxk) !!$  call fftwrk(plan3_zynr_zynk,zyr,zyk) !!$  call fftwrk(plan3_zznr_zznk,zzr,zzk) !!$   if (mype.eq.0) then !!$     print*,' max of diff = ', maxval(real((zzk-azk)*conjg(zzk-azk))) !!$   endif zxk = axk zyk = ayk zzk = azk uk = bxk vk = byk wk = bzk return 5045 format ( 1 x , f12 . 2 , 2 x , 5 ( e11 . 4 , 1 x )) end subroutine pvcomp end module misc","tags":"","loc":"sourcefile/misc.f90.html"},{"title":"forcing.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module contains the forcing and all related functions                                     !!\nIt can force the waves or geostrophic or all modes                                             !!\nSee Waite 2017 Physics of Fluids for more details on forcing scheme                            !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module contains the forcing and all related functions                                     !! !! It can force the waves or geostrophic or all modes                                             !! !! See Waite 2017 Physics of Fluids for more details on forcing scheme                            !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module forcing use param use velvorproj implicit none ! ----------------------------------------------------------------- ! PARAMETERS (for forcing) real , parameter :: kf = 3. ! wavenumber for forcing real , parameter :: tau = 90 0. ! time scale for forcing real , parameter :: alpha = exp ( - delt / tau ) ! memory parameter real , parameter :: eps = 4.e-8 ! approx target dissipation rate for forcing amplitude real , parameter :: ampv = 1.2e-3 / sqrt ( tau ) ! random forcing amplitude real , parameter :: ampw = 0. ! random wave forcing amplitude (when used) integer , parameter :: nfmax = 1200 ! max number of forced modes ! Make internal variables and functions private ! PRIVATE :: CONTAINS subroutine force ( nzxk , nzyk , nzzk , nttk , gtau , nt ) ! Use this after call convol.  Forcing is specified to be divergence-free ! Forcing follows Herring & Metais, 1989, J. Fluid Mech 202, pp. 97-115 implicit none include 'mpif.h' complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: nzxk , nzyk , nzzk , nttk complex , intent ( inout ) :: gtau ( 1200 , 4 ) integer , intent ( in ) :: nt integer :: ikx , iky , ikz , ikza , ik complex :: fu , fv , fw , ft , f1k , f2k , f3k , ftk real :: rang , beta , c , g , tf , theta real :: kx , ky , kz , wkh , wk , wkh2 , sk real :: pk , pp , tmp beta = sqrt ( 1. - alpha ** 2 ) c = sqrt ( bj / ( 2. * aj )) ik = 0 pk = 0. pp = 0. do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx if ( L ( ikx , iky , ikz ). eq . 1 ) then kx = kxa ( ikx ) wkh2 = kx ** 2 + ky ** 2 wkh = sqrt ( wkh2 ) wk = sqrt ( kx ** 2 + ky ** 2 + kz ** 2 ) theta = wkh / wk tf = 1. / sqrt2 ! FORCE modes inside spherical shell centered on k=kf, AND exclude VSHF if ( abs ( wkh * L1 / twopi - KF ). le . 1. . and . abs ( abs ( kz ) * L3 / twopi - 1. ). lt . 0.5 ) then ik = ik + 1 gtau ( ik , 1 ) = alpha * gtau ( ik , 1 ) + beta * cmplx ( rang ( 0 ), rang ( 0 )) gtau ( ik , 2 ) = alpha * gtau ( ik , 2 ) + beta * cmplx ( rang ( 0 ), rang ( 0 )) gtau ( ik , 3 ) = alpha * gtau ( ik , 3 ) + beta * cmplx ( rang ( 0 ), rang ( 0 )) gtau ( ik , 4 ) = alpha * gtau ( ik , 4 ) + beta * cmplx ( rang ( 0 ), rang ( 0 )) !!! specify amplitudes of vort and wave forcing separately G = 1. Fv = ampv * G * gtau ( ik , 1 ) Fw = ampw * G * ( gtau ( ik , 2 ) + gtau ( ik , 3 )) Ft = ampw * G * ( - gtau ( ik , 2 ) + gtau ( ik , 3 )) sk = sqrt ( BF2 * wkh2 + cor2 * kz ** 2 ) f1k = - kx * kz * BF / sk * Fv - wk * ky / wkh / sqrt2 * Fw + ZI * cor * kx * kz ** 2 / sqrt2 / sk / wkh * Ft f2k = - ky * kz * BF / sk * Fv + wk * kx / wkh / sqrt2 * Fw + ZI * cor * ky * kz ** 2 / sqrt2 / sk / wkh * Ft f3k = BF * wkh ** 2 / sk * Fv - ZI * cor * wkh * kz / sqrt2 / sk * Ft ftk = - C * sqrt2 * ZI * cor * kz / sk * Fv + C * BF * wkh / sk * Ft nzxk ( ikx , iky , ikz ) = nzxk ( ikx , iky , ikz ) + f1k nzyk ( ikx , iky , ikz ) = nzyk ( ikx , iky , ikz ) + f2k nzzk ( ikx , iky , ikz ) = nzzk ( ikx , iky , ikz ) + f3k nttk ( ikx , iky , ikz ) = nttk ( ikx , iky , ikz ) + ftk ! compute power from forcing !!$                 pk = pk + real(conjg(zx(ikx,iky,ikz))*f1k/wk2) !!$                 pk = pk + real(conjg(zy(ikx,iky,ikz))*f2k/wk2) !!$                 pk = pk + real(conjg(zz(ikx,iky,ikz))*f3k/wk2) !!$                 pp = pp + real(conjg(tt(ikx,iky,ikz))*ftk)*aj/bj !!! new: force everything isotropically. Use ampv as global amplitude. ! G = (wk*L1/twopi-(kf-1.))*(kf+1.-wk*L1/twopi) ! Fu = ampv * G * gtau(ik,1) ! Fv = ampv * G * gtau(ik,2) ! Fw = ampv * G * gtau(ik,3) ! Ft = ampv * G * gtau(ik,4) *sqrt(bj/aj) ! nzxk(ikx,iky,ikz) = nzxk(ikx,iky,ikz) + zi*(ky*Fw-kz*Fv) ! nzyk(ikx,iky,ikz) = nzyk(ikx,iky,ikz) + zi*(kz*Fu-kx*Fw) ! nzzk(ikx,iky,ikz) = nzzk(ikx,iky,ikz) + zi*(kx*Fv-ky*Fu) ! nttk(ikx,iky,ikz) = nttk(ikx,iky,ikz) + Ft if ( ik . eq . nfmax ) then print * , 'Forcing too many modes!' stop endif endif endif enddo enddo enddo pk = 2. * pk pp = 2. * pp ! for output times, write power to file !!$  if (mod(nt,ndiagevery).eq. 0 ) then !!$     call mpi_reduce(pk,tmp,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,istatus); pk=tmp !!$     call mpi_reduce(pp,tmp,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,istatus); pp=tmp !!$     if (mype.eq.0) then !!$        write(98,4999) time,pk,pp !!$        call flush(98) !!$     endif !!$  endif return 4999 format ( 1 x , f12 . 2 , 2 x , 2 ( e21 . 14 , 2 x )) end subroutine force function rang ( i ) ! If i ne 0 then initializes RANNO with seed = i ! If i eq 0 then draws a random GAUSSIAN number with ! mean and std = 1 implicit none include 'mpif.h' real :: rang integer :: i real :: v1 , v2 , R , FAC , twopi , ranno external :: ranno twopi = 4. * asin ( 1. ) if ( i . ne . 0 ) then v1 = ranno ( i ) else 200 v1 = 2. * ( ranno ( 0 ) + twopi / 2. ) / twopi - 1. v2 = 2. * ( ranno ( 0 ) + twopi / 2. ) / twopi - 1. r = v1 ** 2. + v2 ** 2. if ( r . gt . 1. ) goto 200 fac = sqrt ( - 2. * log ( r ) / r ) rang = v1 * fac endif return end function rang function ranno ( i ) ! Controls random number generator. !----------------------------------------- ! - If argument i.ne.0 it performs initialization with i=seed no. ! - If argument i.eq.0 it draws a random no. !----------------------------------------- implicit none include 'mpif.h' real :: ranno integer :: i integer :: junk , ihold real :: twopi , ran1 save junk twopi = 4. * asin ( 1. ) if ( i . ne . 0 ) then if ( i . gt . 0 ) i = - i junk = i ranno = ( ran1 ( i ) - 0.5 ) * twopi else junk = junk - 1 ihold = junk ranno = ( ran1 ( ihold ) - 0.5 ) * twopi endif return end function ranno function ran1 ( idum ) implicit none include 'mpif.h' real :: ran1 integer :: idum integer , parameter :: ia = 16807 , im = 2147483647 , iq = 127773 , ir = 2836 , ntab = 32 , ndiv = 1 + ( im - 1 ) / ntab real , parameter :: am = 1. / im , eps = 1.2e-7 , rnmx = 1. - eps integer :: j , k , iv ( 32 ), iy save iv , iy data iv / ntab * 0 / , iy / 0 / if ( idum . le . 0. or . iy . eq . 0 ) then idum = max ( - idum , 1 ) do j = ntab + 8 , 1 , - 1 k = idum / iq idum = ia * ( idum - k * iq ) - ir * k if ( idum . lt . 0 ) idum = idum + im if ( j . le . ntab ) iv ( j ) = idum enddo iy = iv ( 1 ) endif k = idum / iq idum = ia * ( idum - k * iq ) - ir * k if ( idum . lt . 0 ) idum = idum + im j = 1 + iy / ndiv iy = iv ( j ) iv ( j ) = idum ran1 = min ( am * iy , rnmx ) return end function ran1 end module forcing","tags":"","loc":"sourcefile/forcing.f90.html"},{"title":"init_condition.F90 – Boussinesq DNS","text":"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!\nThis module generates Initial Conditions (IC) for vorticity and temperature (buoyancy) fields  !!\nIt can read a NetCDF as IC                                                                     !!\nor generated IC based on a description in physical or Fourier space                            !!\nor IC can be a superposition of the above                                                      !!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! Source Code !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! !! This module generates Initial Conditions (IC) for vorticity and temperature (buoyancy) fields  !! !! It can read a NetCDF as IC                                                                     !! !! or generated IC based on a description in physical or Fourier space                            !! !! or IC can be a superposition of the above                                                      !! !! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !! module init_condition !  use param use param_fftw use IO_netcdf !  use velvorproj use nm_decomp implicit none ! ----------------------------------------------------------------- ! PARAMETERS (icmode set in param.F90) ! >>>> parameters for peak in energy spectrum ! ki is the index of wavenumber at which IC peaks (in energy spc) ONLY for icmode = 0 real , parameter :: ki = 8.0 real , parameter :: ke_i = 2.0 !  initial kinetic energy ! Make internal variables and functions private PRIVATE :: ranno , ran1 CONTAINS subroutine init_cond ( zx , zy , zz , tt , uu , vv , ww , ge , g1 , g2 , zxr , zyr , zzr , ttr , ur , vr , wr , ts ) ! Define the initial condition implicit none include 'mpif.h' complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt , uu , vv , ww , ge , g1 , g2 real , intent ( out ), dimension ( n1d , n3d , n2dp ) :: zxr , zyr , zzr , ttr , ur , vr , wr real , intent ( out ) :: ts complex , dimension (:,:,:), allocatable :: zx0 , zy0 , zz0 , tt0 if ( icmode == 2 ) then print * , 'This set of scripts cannot handle two-part ICs' call MPI_Abort ( mpi_comm_world , istatus ) !!$     ! superpostion of input NetCDF file and user defined fields !!$     ! for user defined fields you can use the functions in this module like single_planewave ... !!$     allocate(zx0(iktx,ikty,iktzp)) !!$     allocate(zy0(iktx,ikty,iktzp)) !!$     allocate(zz0(iktx,ikty,iktzp)) !!$     allocate(tt0(iktx,ikty,iktzp)) !!$     call ncreadin(zx,zy,zz,tt,ts) !!$ !!$     ! superposing the wave field and background QG !!$     zx = zx + zx0 !!$     zy = zy + zy0 !!$     zz = zz + zz0 !!$     tt = tt + tt0 !!$ !!$     ! free the memory for auxilliary variables !!$     deallocate(zx0,zy0,zz0,tt0) elseif ( icmode == 1 ) then call ncreadin ( zx , zy , zz , tt , ts ) if ( mype . eq . 0 ) then write ( iuRESULT , * ) '                ' write ( iuRESULT , * ) 'Initial Condition: ---------------------------------------' write ( iuRESULT , * ) 'Starting from Zk.in.ncf' call flush ( iuRESULT ) endif else ! (icmode==0) call exp_peak ( zx , zy , zz , tt , uu , vv , ww , ge , g1 , g2 ) if ( mype . eq . 0 ) then write ( iuRESULT , * ) '                ' write ( iuRESULT , * ) 'Initial Condition: ---------------------------------------' write ( iuRESULT , * ) 'Starting from a Guassian Peak in Eng. Spec' write ( iuRESULT , * ) '            peak at ki = ' , ki write ( iuRESULT , * ) '      initial kin eng. = ' , ke_i call flush ( iuRESULT ) endif endif call wtoab ( zx , zy , zz , tt , ge , g1 , g2 , uu , vv , ww ) call proj ( zx , zy , zz ) return end subroutine init_cond subroutine exp_peak ( zx , zy , zz , tt , uu , vv , ww , ge , g1 , g2 ) !!! Initialize in Fourier space with Gausian peak at ki (defined above) implicit none include 'mpif.h' complex , intent ( out ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt , uu , vv , ww , ge , g1 , g2 integer :: ikx , iky , ikz , ikza real :: kx , ky , kz , wk , kh , khn , wkn , kzn real :: phase , EK real :: kinen , poten , vorten , waven do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wk = sqrt ( kx * kx + ky * ky + kz * kz ) khn = sqrt (( kx * L1 / twopi ) ** 2 + ( ky * L2 / twopi ) ** 2 ) wkn = sqrt (( kx * L1 / twopi ) ** 2 + ( ky * L2 / twopi ) ** 2 + ( kz * L3 / twopi ) ** 2 ) kzn = kz * L3 / twopi if ( L ( ikx , iky , ikz ). eq . 1 ) then EK = exp ( - (( wkn - ki ) / 5. ) ** 2 ) phase = ranno ( 0 ) zx ( ikx , iky , ikz ) = wk * sqrt ( EK ) * cexp ( ZI * phase ) phase = ranno ( 0 ) zy ( ikx , iky , ikz ) = wk * sqrt ( EK ) * cexp ( ZI * phase ) phase = ranno ( 0 ) zz ( ikx , iky , ikz ) = wk * sqrt ( EK ) * cexp ( ZI * phase ) phase = ranno ( 0 ) tt ( ikx , iky , ikz ) = sqrt ( EK ) * cexp ( ZI * phase ) phase = ranno ( 0 ) if ( kx . eq . 0. ) then zx ( ikx , iky , ikz ) = 1e-2 * cmplx ( real ( zx ( ikx , iky , ikz )), 0. ) zy ( ikx , iky , ikz ) = 1e-2 * cmplx ( real ( zy ( ikx , iky , ikz )), 0. ) zz ( ikx , iky , ikz ) = 1e-2 * cmplx ( real ( zz ( ikx , iky , ikz )), 0. ) endif endif enddo enddo enddo call wtoab ( zx , zy , zz , tt , ge , g1 , g2 , uu , vv , ww ) g1 = cmplx ( 0. , 0. ) g2 = cmplx ( 0. , 0. ) call atowb ( ge , g1 , g2 , zx , zy , zz , tt , uu , vv , ww ) call proj ( zx , zy , zz ) ! normalizing the initial condition call energy_full ( zx , zy , zz , tt , uu , vv , ww , ge , g1 , g2 , kinen , poten , vorten , waven ) zx = sqrt ( ke_i / kinen ) * zx zy = sqrt ( ke_i / kinen ) * zy zz = sqrt ( ke_i / kinen ) * zz tt = sqrt ( ke_i / kinen ) * tt end subroutine exp_peak subroutine energy_full ( zx , zy , zz , tt , ux , uy , uz , ge , g1 , g2 , ke , pe , eg , ea ) ! Computes total energy (KE, PE, VE, WE) implicit none include 'mpif.h' complex , intent ( in ), dimension ( iktx , ikty , iktzp ) :: zx , zy , zz , tt complex , intent ( inout ), dimension ( iktx , ikty , iktzp ) :: ux , uy , uz , ge , g1 , g2 real , intent ( out ) :: ke , pe , eg , ea integer :: ikx , iky , ikz , ikza real :: kx , ky , kz , wk , wkh2 , wkh2n , kzn real :: vh , vzx , vzy , vzz , vz real :: zero_kz_geo , zero_kz_grv , zero_kh_grv , zero_kh_geo , tmp call velo ( zx , zy , zz , ux , uy , uz ) call wtoab ( zx , zy , zz , tt , ge , g1 , g2 , ux , uy , uz ) zero_kz_geo = 0. zero_kz_grv = 0. zero_kh_geo = 0. zero_kh_grv = 0. ke = 0. pe = 0. eg = 0. ea = 0. do ikz = 1 , iktzp ikza = mype * iktzp + ikz kz = kza ( ikza ) kzn = kz * L3 / twopi do iky = 1 , ikty ky = kya ( iky ) do ikx = 1 , iktx kx = kxa ( ikx ) wkh2 = kx * kx + ky * ky wkh2n = wkh2 * ( L1 / twopi ) ** 2 wk = kx * kx + ky * ky + kz * kz if ( L ( ikx , iky , ikz ). eq . 1 ) then wk = max ( wk , 1.e-15 ) wkh2 = max ( wkh2 , 1.e-15 ) vzx = real ( zx ( ikx , iky , ikz ) * conjg ( zx ( ikx , iky , ikz )) ) ke = ke + vzx / wk vzy = real ( zy ( ikx , iky , ikz ) * conjg ( zy ( ikx , iky , ikz )) ) ke = ke + vzy / wk vzz = real ( zz ( ikx , iky , ikz ) * conjg ( zz ( ikx , iky , ikz )) ) ke = ke + vzz / wk vh = real ( tt ( ikx , iky , ikz ) * conjg ( tt ( ikx , iky , ikz )) ) pe = pe + vh vzx = real ( ux ( ikx , iky , ikz ) * conjg ( ux ( ikx , iky , ikz )) ) vzy = real ( uy ( ikx , iky , ikz ) * conjg ( uy ( ikx , iky , ikz )) ) vzz = real ( uz ( ikx , iky , ikz ) * conjg ( uz ( ikx , iky , ikz )) ) if ( wkh2n . lt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then zero_kh_grv = zero_kh_grv + vzx + vzy zero_kh_geo = zero_kh_geo + VH * aj / bj endif if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). lt . 1.e-10 ) then zero_kz_geo = zero_kz_geo + VZX + VZY zero_kz_grv = zero_kz_grv + VZZ + VH * aj / bj endif if ( wkh2n . gt . 1.e-10 . and . abs ( kzn ). gt . 1.e-10 ) then vz = real ( ge ( ikx , iky , ikz ) * conjg ( ge ( ikx , iky , ikz ))) eg = eg + vz / wkh2 vz = real ( g1 ( ikx , iky , ikz ) * conjg ( g1 ( ikx , iky , ikz ))) ea = ea + vz / wkh2 vz = real ( g2 ( ikx , iky , ikz ) * conjg ( g2 ( ikx , iky , ikz ))) ea = ea + vz / wkh2 endif endif enddo enddo enddo if ( aj . ne . 0. . and . bj . ne . 0. ) pe = aj * pe / bj eg = eg + zero_kz_geo + zero_kh_geo ea = ea + zero_kz_grv + zero_kh_grv call mpi_allreduce ( ke , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); ke = tmp call mpi_allreduce ( pe , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); pe = tmp call mpi_allreduce ( eg , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); eg = tmp call mpi_allreduce ( ea , tmp , 1 , MPI_REAL , MPI_SUM , MPI_COMM_WORLD , istatus ); ea = tmp end subroutine energy_full function ranno ( i ) ! Controls random number generator. !----------------------------------------- ! - If argument i.ne.0 it performs initialization with i=seed no. ! - If argument i.eq.0 it draws a random no. !----------------------------------------- implicit none real :: ranno integer :: i integer :: junk , ihold real :: twopi , ran1 save junk twopi = 4. * asin ( 1. ) if ( i . ne . 0 ) then if ( i . gt . 0 ) i = - i junk = i ranno = ( ran1 ( i ) - 0.5 ) * twopi else junk = junk - 1 ihold = junk ranno = ( ran1 ( ihold ) - 0.5 ) * twopi endif return end function ranno function ran1 ( idum ) implicit none real :: ran1 integer :: idum integer , parameter :: ia = 16807 , im = 2147483647 , iq = 127773 , ir = 2836 , ntab = 32 , ndiv = 1 + ( im - 1 ) / ntab real , parameter :: am = 1. / im , eps = 1.2e-7 , rnmx = 1. - eps integer :: j , k , iv ( 32 ), iy save iv , iy data iv / ntab * 0 / , iy / 0 / if ( idum . le . 0. or . iy . eq . 0 ) then idum = max ( - idum , 1 ) do j = ntab + 8 , 1 , - 1 k = idum / iq idum = ia * ( idum - k * iq ) - ir * k if ( idum . lt . 0 ) idum = idum + im if ( j . le . ntab ) iv ( j ) = idum enddo iy = iv ( 1 ) endif k = idum / iq idum = ia * ( idum - k * iq ) - ir * k if ( idum . lt . 0 ) idum = idum + im j = 1 + iy / ndiv iy = iv ( j ) iv ( j ) = idum ran1 = min ( am * iy , rnmx ) return end function ran1 end module init_condition","tags":"","loc":"sourcefile/init_condition.f90.html"}]}